


<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>(prototype) Graph Mode Post Training Static Quantization in PyTorch &mdash; PyTorch Tutorials 1.6.0 documentation</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <!-- <link rel="stylesheet" href="../_static/pygments.css" type="text/css" /> -->
  <link rel="stylesheet" href="../_static/gallery.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 

  
  <script src="../_static/js/modernizr.min.js"></script>

  <!-- Preload the theme fonts -->

<link rel="preload" href="../_static/fonts/FreightSans/freight-sans-book.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="../_static/fonts/FreightSans/freight-sans-medium.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="../_static/fonts/IBMPlexMono/IBMPlexMono-Medium.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="../_static/fonts/FreightSans/freight-sans-bold.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="../_static/fonts/FreightSans/freight-sans-medium-italic.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="../_static/fonts/IBMPlexMono/IBMPlexMono-SemiBold.woff2" as="font" type="font/woff2" crossorigin="anonymous">

<!-- Preload the katex fonts -->

<link rel="preload" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/fonts/KaTeX_Math-Italic.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/fonts/KaTeX_Main-Regular.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/fonts/KaTeX_Main-Bold.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/fonts/KaTeX_Size1-Regular.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/fonts/KaTeX_Size4-Regular.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/fonts/KaTeX_Size2-Regular.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/fonts/KaTeX_Size3-Regular.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/fonts/KaTeX_Caligraphic-Regular.woff2" as="font" type="font/woff2" crossorigin="anonymous">
</head>

<body class="pytorch-body">
  <nav class="navbar sticky-top navbar-dark fixed-top navbar-expand-lg" style="background: rgba(55,55,55,.8)">
    <div class="container-fluid">
      <div class="navbar-brand">
        <a href="https://pytorch.kr/" aria-label="PyTorch">
          <img src="../_static/images/logo-kr.svg" width="260" height="28" fill="white" />
        </a>
      </div>
      <button type="button" aria-label="Toggle navigation" class="navbar-toggler collapsed" aria-expanded="false" aria-controls="nav-collapse"><span class="navbar-toggler-icon"></span></button>
      <div id="nav-collapse" class="navbar-collapse collapse">
        <ul class="navbar-nav ml-auto">
          <li class="nav-item">
            <a href="//pytorch.kr/" target="_self" class="nav-link">홈</a></li>
          <li class="nav-item">
            <a href="//tutorials.pytorch.kr/" target="_self" class="nav-link">튜토리얼</a>
          </li>
          <li class="nav-item">
            <a href="//pytorch.kr/about" target="_self" class="nav-link">
              소개
            </a></li>
        </ul>
      </div>
    </div>
  </nav>

   

    

    <div class="table-of-contents-link-wrapper">
      <span>Table of Contents</span>
      <a href="#" class="toggle-table-of-contents" data-behavior="toggle-table-of-contents"></a>
    </div>

    <nav data-toggle="wy-nav-shift" class="pytorch-left-menu" id="pytorch-left-menu">
      <div class="pytorch-side-scroll">
        <div class="pytorch-menu pytorch-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          <div class="pytorch-left-menu-search">
            

            
              
              
                <div class="version">
                  1.6.0
                </div>
              
            

            


  


<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search Tutorials" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

            
          </div>

          
            
            
              
            
            
              <p class="caption"><span class="caption-text">파이토치(PyTorch) 레시피</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../recipes/recipes_index.html">모든 레시피 보기</a></li>
</ul>
<p class="caption"><span class="caption-text">파이토치(PyTorch) 배우기</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../beginner/deep_learning_60min_blitz.html">파이토치(PyTorch)로 딥러닝하기: 60분만에 끝장내기</a></li>
<li class="toctree-l1"><a class="reference internal" href="../beginner/pytorch_with_examples.html">예제로 배우는 파이토치(PyTorch)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../beginner/nn_tutorial.html"><cite>torch.nn</cite> 이 <em>실제로</em> 무엇인가요?</a></li>
<li class="toctree-l1"><a class="reference internal" href="../intermediate/tensorboard_tutorial.html">TensorBoard로 모델, 데이터, 학습 시각화하기</a></li>
</ul>
<p class="caption"><span class="caption-text">이미지/비디오</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../intermediate/torchvision_tutorial.html">TorchVision 객체 검출 미세조정(Finetuning) 튜토리얼</a></li>
<li class="toctree-l1"><a class="reference internal" href="../beginner/transfer_learning_tutorial.html">컴퓨터 비전(Vision)을 위한 전이학습(Transfer Learning)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../beginner/fgsm_tutorial.html">적대적 예제 생성(Adversarial Example Generation)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../beginner/dcgan_faces_tutorial.html">DCGAN Tutorial</a></li>
</ul>
<p class="caption"><span class="caption-text">오디오</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../beginner/audio_preprocessing_tutorial.html">torchaudio Tutorial</a></li>
</ul>
<p class="caption"><span class="caption-text">텍스트</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../beginner/transformer_tutorial.html">nn.Transformer 와 TorchText 로 시퀀스-투-시퀀스(Sequence-to-Sequence) 모델링하기</a></li>
<li class="toctree-l1"><a class="reference internal" href="../intermediate/char_rnn_classification_tutorial.html">기초부터 시작하는 NLP: 문자-단위 RNN으로 이름 분류하기</a></li>
<li class="toctree-l1"><a class="reference internal" href="../intermediate/char_rnn_generation_tutorial.html">기초부터 시작하는 NLP:  문자-단위 RNN으로 이름 생성하기</a></li>
<li class="toctree-l1"><a class="reference internal" href="../intermediate/seq2seq_translation_tutorial.html">기초부터 시작하는 NLP: Sequence to Sequence 네트워크와 Attention을 이용한 번역</a></li>
<li class="toctree-l1"><a class="reference internal" href="../beginner/text_sentiment_ngrams_tutorial.html">TorchText로 텍스트 분류하기</a></li>
<li class="toctree-l1"><a class="reference internal" href="../beginner/torchtext_translation_tutorial.html">TorchText로 언어 번역하기</a></li>
</ul>
<p class="caption"><span class="caption-text">강화학습</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../intermediate/reinforcement_q_learning.html">강화 학습 (DQN) 튜토리얼</a></li>
</ul>
<p class="caption"><span class="caption-text">PyTorch 모델을 프로덕션 환경에 배포하기</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../intermediate/flask_rest_api_tutorial.html">Flask를 이용하여 Python에서 PyTorch를 REST API로 배포하기</a></li>
<li class="toctree-l1"><a class="reference internal" href="../beginner/Intro_to_TorchScript_tutorial.html">TorchScript 소개</a></li>
<li class="toctree-l1"><a class="reference internal" href="../advanced/cpp_export.html">C++에서 TorchScript 모델 로딩하기</a></li>
<li class="toctree-l1"><a class="reference internal" href="../advanced/super_resolution_with_onnxruntime.html">(선택) PyTorch 모델을 ONNX으로 변환하고 ONNX 런타임에서 실행하기</a></li>
</ul>
<p class="caption"><span class="caption-text">프론트엔드 API</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../intermediate/named_tensor_tutorial.html">(prototype) Introduction to Named Tensors in PyTorch</a></li>
<li class="toctree-l1"><a class="reference internal" href="../intermediate/memory_format_tutorial.html">(beta) Channels Last Memory Format in PyTorch</a></li>
<li class="toctree-l1"><a class="reference internal" href="../advanced/cpp_frontend.html">Using the PyTorch C++ Frontend</a></li>
<li class="toctree-l1"><a class="reference internal" href="../advanced/cpp_extension.html">Custom C++ and CUDA Extensions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../advanced/torch_script_custom_ops.html">Extending TorchScript with Custom C++ Operators</a></li>
<li class="toctree-l1"><a class="reference internal" href="../advanced/torch_script_custom_classes.html">Extending TorchScript with Custom C++ Classes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../advanced/torch-script-parallelism.html">Dynamic Parallelism in TorchScript</a></li>
<li class="toctree-l1"><a class="reference internal" href="../advanced/cpp_autograd.html">Autograd in C++ Frontend</a></li>
<li class="toctree-l1"><a class="reference internal" href="../advanced/dispatcher.html">Dispatcher in C++</a></li>
</ul>
<p class="caption"><span class="caption-text">모델 최적화</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../intermediate/pruning_tutorial.html">가지치기 기법(Pruning) 튜토리얼</a></li>
<li class="toctree-l1"><a class="reference internal" href="../advanced/dynamic_quantization_tutorial.html">(beta) Dynamic Quantization on an LSTM Word Language Model</a></li>
<li class="toctree-l1"><a class="reference internal" href="../intermediate/dynamic_quantization_bert_tutorial.html">(베타) BERT 모델 동적 양자화하기</a></li>
<li class="toctree-l1"><a class="reference internal" href="../advanced/static_quantization_tutorial.html">(beta) Static Quantization with Eager Mode in PyTorch</a></li>
<li class="toctree-l1"><a class="reference internal" href="../intermediate/quantized_transfer_learning_tutorial.html">(beta) 컴퓨터 비전(Vision) 튜토리얼을 위한 양자화된 전이학습(Quantized Transfer Learning)</a></li>
</ul>
<p class="caption"><span class="caption-text">병렬 및 분산 학습</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../beginner/dist_overview.html">PyTorch Distributed Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../intermediate/model_parallel_tutorial.html">단일 머신을 이용한 모델 병렬화 실습 예제</a></li>
<li class="toctree-l1"><a class="reference internal" href="../intermediate/ddp_tutorial.html">Getting Started with Distributed Data Parallel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../intermediate/dist_tuto.html">PyTorch로 분산 어플리케이션 개발하기</a></li>
<li class="toctree-l1"><a class="reference internal" href="../intermediate/rpc_tutorial.html">Getting Started with Distributed RPC Framework</a></li>
<li class="toctree-l1"><a class="reference internal" href="../beginner/aws_distributed_training_tutorial.html">(advanced) PyTorch 1.0 Distributed Trainer with Amazon AWS</a></li>
<li class="toctree-l1"><a class="reference internal" href="../intermediate/rpc_param_server_tutorial.html">Implementing a Parameter Server Using Distributed RPC Framework</a></li>
<li class="toctree-l1"><a class="reference internal" href="../intermediate/dist_pipeline_parallel_tutorial.html">Distributed Pipeline Parallelism Using RPC</a></li>
<li class="toctree-l1"><a class="reference internal" href="../intermediate/rpc_async_execution.html">Implementing Batch RPC Processing Using Asynchronous Executions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../advanced/rpc_ddp_tutorial.html">Combining Distributed DataParallel with Distributed RPC Framework</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <div class="pytorch-container">
      <div class="pytorch-page-level-bar" id="pytorch-page-level-bar">
        <div class="pytorch-breadcrumbs-wrapper">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="pytorch-breadcrumbs">
    
      <li>
        <a href="../index.html">
          
            Tutorials
          
        </a> &gt;
      </li>

        
      <li>(prototype) Graph Mode Post Training Static Quantization in PyTorch</li>
    
    
      <li class="pytorch-breadcrumbs-aside">
        
            
            <a href="../_sources/prototype/graph_mode_static_quantization_tutorial.rst.txt" rel="nofollow"><img src="../_static/images/view-page-source-icon.svg"></a>
          
        
      </li>
    
  </ul>

  
</div>
        </div>

        <div class="pytorch-shortcuts-wrapper" id="pytorch-shortcuts-wrapper">
          Shortcuts
        </div>
      </div>

      <section data-toggle="wy-nav-shift" id="pytorch-content-wrap" class="pytorch-content-wrap">
        <div class="pytorch-content-left">

        

          <div class="pytorch-call-to-action-links">
            <div id="tutorial-type">prototype/graph_mode_static_quantization_tutorial</div>

            <div id="google-colab-link">
              <img class="call-to-action-img" src="../_static/images/pytorch-colab.svg"/>
              <div class="call-to-action-desktop-view">Run in Google Colab</div>
              <div class="call-to-action-mobile-view">Colab</div>
            </div>
            <div id="download-notebook-link">
              <img class="call-to-action-notebook-img" src="../_static/images/pytorch-download.svg"/>
              <div class="call-to-action-desktop-view">Download Notebook</div>
              <div class="call-to-action-mobile-view">Notebook</div>
            </div>
            <div id="github-view-link">
              <img class="call-to-action-img" src="../_static/images/pytorch-github.svg"/>
              <div class="call-to-action-desktop-view">View on GitHub</div>
              <div class="call-to-action-mobile-view">GitHub</div>
            </div>
          </div>

        
          
          <div class="rst-content">
          
            <div role="main" class="main-content" itemscope="itemscope" itemtype="http://schema.org/Article">
             <article itemprop="articleBody" id="pytorch-article" class="pytorch-article">
              
  <div class="sphx-glr-download-link-note admonition note">
<p class="admonition-title">Note</p>
<p>Click <a class="reference internal" href="#sphx-glr-download-prototype-graph-mode-static-quantization-tutorial-py"><span class="std std-ref">here</span></a> to download the full example code</p>
</div>
<div class="sphx-glr-example-title section" id="prototype-graph-mode-post-training-static-quantization-in-pytorch">
<span id="sphx-glr-prototype-graph-mode-static-quantization-tutorial-py"></span><h1>(prototype) Graph Mode Post Training Static Quantization in PyTorch<a class="headerlink" href="#prototype-graph-mode-post-training-static-quantization-in-pytorch" title="Permalink to this headline">¶</a></h1>
<p><strong>Author</strong>: <a class="reference external" href="https://github.com/jerryzh168">Jerry Zhang</a></p>
<p>This tutorial introduces the steps to do post training static quantization in graph mode.
The advantage of graph mode quantization is that as long as the model can be scripted or traced,
we can perform quantization fully automatically on the model.
Right now we can do post training static and post training dynamic quantization
and quantization aware training support will come later.
We have a separate tutorial for <a class="reference external" href="https://pytorch.org/tutorials/prototype_source/graph_mode_dynamic_bert_tutorial.html">Graph Mode Post Training Dynamic Quantization</a>.</p>
<p>tldr; The graph mode API looks like the following:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">torch</span>
<span class="kn">from</span> <span class="nn">torch.quantization</span> <span class="kn">import</span> <span class="n">get_default_qconfig</span><span class="p">,</span> <span class="n">quantize_jit</span>

<span class="n">ts_model</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">jit</span><span class="o">.</span><span class="n">script</span><span class="p">(</span><span class="n">float_model</span><span class="o">.</span><span class="n">eval</span><span class="p">())</span> <span class="c1"># or torch.jit.trace(float_model, input)</span>
<span class="n">qconfig</span> <span class="o">=</span> <span class="n">get_default_qconfig</span><span class="p">(</span><span class="s1">&#39;fbgemm&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">calibrate</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">data_loader</span><span class="p">):</span>
    <span class="n">model</span><span class="o">.</span><span class="n">eval</span><span class="p">()</span>
    <span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">no_grad</span><span class="p">():</span>
        <span class="k">for</span> <span class="n">image</span><span class="p">,</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">data_loader</span><span class="p">:</span>
            <span class="n">model</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
<span class="n">quantized_model</span> <span class="o">=</span> <span class="n">quantize_jit</span><span class="p">(</span>
    <span class="n">ts_model</span><span class="p">,</span> <span class="c1"># TorchScript model</span>
    <span class="p">{</span><span class="s1">&#39;&#39;</span><span class="p">:</span> <span class="n">qconfig</span><span class="p">},</span> <span class="c1"># qconfig dict</span>
    <span class="n">calibrate</span><span class="p">,</span> <span class="c1"># calibration function</span>
    <span class="p">[</span><span class="n">data_loader_test</span><span class="p">])</span> <span class="c1"># positional arguments to calibration function, typically some sample dataset</span>
</pre></div>
</div>
<div class="section" id="motivation-of-graph-mode-quantization">
<h2>1. Motivation of Graph Mode Quantization<a class="headerlink" href="#motivation-of-graph-mode-quantization" title="Permalink to this headline">¶</a></h2>
<p>Currently PyTorch only has eager mode quantization: <a class="reference external" href="https://pytorch.org/tutorials/advanced/static_quantization_tutorial.html">Static Quantization with Eager Mode in PyTorch</a>.</p>
<p>We can see there are multiple manual steps involved in the process, including:</p>
<ul class="simple">
<li><p>Explicitly quantize and dequantize activations, this is time consuming when floating point and quantized operations are mixed in a model.</p></li>
<li><p>Explicitly fuse modules, this requires manually identifying the sequence of convolutions, batch norms and relus and other fusion patterns.</p></li>
<li><p>Special handling is needed for pytorch tensor operations (like add, concat etc.)</p></li>
<li><p>Functionals did not have first class support (functional.conv2d and functional.linear would not get quantized)</p></li>
</ul>
<p>Most of these required modifications comes from the underlying limitations of eager mode quantization. Eager mode works in module level since it can not inspect the code that is actually run (in the forward function), quantization is achieved by module swapping, and we don’t know how the modules are used in forward function in eager mode, so it requires users to insert QuantStub and DeQuantStub manually to mark the points they want to quantize or dequantize.
In graph mode, we can inspect the actual code that’s been executed in forward function (e.g. aten function calls) and quantization is achieved by module and graph manipulations. Since graph mode has full visibility of the code that is run, our tool is able to automatically figure out things like which modules to fuse and where to insert observer calls, quantize/dequantize functions etc., we are able to automate the whole quantization process.</p>
<p>Advantages of graph mode quantization are:</p>
<ul class="simple">
<li><p>Simple quantization flow, minimal manual steps</p></li>
<li><p>Unlocks the possibility of doing higher level optimizations like automatic precision selection</p></li>
</ul>
<p>Limitations of graph mode quantization is that quantization is configurable only at the level of module and the set of operators that are quantized is not configurable by user currently.</p>
</div>
<div class="section" id="define-helper-functions-and-prepare-dataset">
<h2>2. Define Helper Functions and Prepare Dataset<a class="headerlink" href="#define-helper-functions-and-prepare-dataset" title="Permalink to this headline">¶</a></h2>
<p>We’ll start by doing the necessary imports, defining some helper functions and prepare the data.
These steps are identitcal to <a class="reference external" href="https://pytorch.org/tutorials/advanced/static_quantization_tutorial.html">Static Quantization with Eager Mode in PyTorch</a>.</p>
<p>Download dataset:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">wget</span> <span class="n">https</span><span class="p">:</span><span class="o">//</span><span class="n">s3</span><span class="o">.</span><span class="n">amazonaws</span><span class="o">.</span><span class="n">com</span><span class="o">/</span><span class="n">pytorch</span><span class="o">-</span><span class="n">tutorial</span><span class="o">-</span><span class="n">assets</span><span class="o">/</span><span class="n">imagenet_1k</span><span class="o">.</span><span class="n">zip</span>
</pre></div>
</div>
<p>and unzip to <cite>data</cite> folder.
Download the <a class="reference external" href="https://github.com/pytorch/vision/blob/master/torchvision/models/resnet.py#L12">torchvision resnet18 model</a> and rename it to
<code class="docutils literal notranslate"><span class="pre">data/resnet18_pretrained_float.pth</span></code>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">torch</span>
<span class="kn">import</span> <span class="nn">torch.nn</span> <span class="k">as</span> <span class="nn">nn</span>
<span class="kn">import</span> <span class="nn">torchvision</span>
<span class="kn">from</span> <span class="nn">torch.utils.data</span> <span class="k">import</span> <span class="n">DataLoader</span>
<span class="kn">from</span> <span class="nn">torchvision</span> <span class="k">import</span> <span class="n">datasets</span>
<span class="kn">import</span> <span class="nn">torchvision.transforms</span> <span class="k">as</span> <span class="nn">transforms</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">torch.quantization</span>

<span class="c1"># # Setup warnings</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="n">warnings</span><span class="o">.</span><span class="n">filterwarnings</span><span class="p">(</span>
    <span class="n">action</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">,</span>
    <span class="n">category</span><span class="o">=</span><span class="ne">DeprecationWarning</span><span class="p">,</span>
    <span class="n">module</span><span class="o">=</span><span class="sa">r</span><span class="s1">&#39;.*&#39;</span>
<span class="p">)</span>
<span class="n">warnings</span><span class="o">.</span><span class="n">filterwarnings</span><span class="p">(</span>
    <span class="n">action</span><span class="o">=</span><span class="s1">&#39;default&#39;</span><span class="p">,</span>
    <span class="n">module</span><span class="o">=</span><span class="sa">r</span><span class="s1">&#39;torch.quantization&#39;</span>
<span class="p">)</span>

<span class="c1"># Specify random seed for repeatable results</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">manual_seed</span><span class="p">(</span><span class="mi">191009</span><span class="p">)</span>


<span class="kn">from</span> <span class="nn">torchvision.models.resnet</span> <span class="k">import</span> <span class="n">resnet18</span>
<span class="kn">from</span> <span class="nn">torch.quantization</span> <span class="k">import</span> <span class="n">get_default_qconfig</span><span class="p">,</span> <span class="n">quantize_jit</span>

<span class="k">class</span> <span class="nc">AverageMeter</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Computes and stores the average and current value&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">fmt</span><span class="o">=</span><span class="s1">&#39;:f&#39;</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fmt</span> <span class="o">=</span> <span class="n">fmt</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">avg</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sum</span> <span class="o">+=</span> <span class="n">val</span> <span class="o">*</span> <span class="n">n</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">count</span> <span class="o">+=</span> <span class="n">n</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">avg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sum</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">count</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">fmtstr</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{name}</span><span class="s1"> {val&#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">fmt</span> <span class="o">+</span> <span class="s1">&#39;} ({avg&#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">fmt</span> <span class="o">+</span> <span class="s1">&#39;})&#39;</span>
        <span class="k">return</span> <span class="n">fmtstr</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">accuracy</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">topk</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,)):</span>
    <span class="sd">&quot;&quot;&quot;Computes the accuracy over the k top predictions for the specified values of k&quot;&quot;&quot;</span>
    <span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">no_grad</span><span class="p">():</span>
        <span class="n">maxk</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">topk</span><span class="p">)</span>
        <span class="n">batch_size</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="n">_</span><span class="p">,</span> <span class="n">pred</span> <span class="o">=</span> <span class="n">output</span><span class="o">.</span><span class="n">topk</span><span class="p">(</span><span class="n">maxk</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="n">pred</span> <span class="o">=</span> <span class="n">pred</span><span class="o">.</span><span class="n">t</span><span class="p">()</span>
        <span class="n">correct</span> <span class="o">=</span> <span class="n">pred</span><span class="o">.</span><span class="n">eq</span><span class="p">(</span><span class="n">target</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">expand_as</span><span class="p">(</span><span class="n">pred</span><span class="p">))</span>

        <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">topk</span><span class="p">:</span>
            <span class="n">correct_k</span> <span class="o">=</span> <span class="n">correct</span><span class="p">[:</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">float</span><span class="p">()</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">keepdim</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">correct_k</span><span class="o">.</span><span class="n">mul_</span><span class="p">(</span><span class="mf">100.0</span> <span class="o">/</span> <span class="n">batch_size</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">res</span>


<span class="k">def</span> <span class="nf">evaluate</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">criterion</span><span class="p">,</span> <span class="n">data_loader</span><span class="p">):</span>
    <span class="n">model</span><span class="o">.</span><span class="n">eval</span><span class="p">()</span>
    <span class="n">top1</span> <span class="o">=</span> <span class="n">AverageMeter</span><span class="p">(</span><span class="s1">&#39;Acc@1&#39;</span><span class="p">,</span> <span class="s1">&#39;:6.2f&#39;</span><span class="p">)</span>
    <span class="n">top5</span> <span class="o">=</span> <span class="n">AverageMeter</span><span class="p">(</span><span class="s1">&#39;Acc@5&#39;</span><span class="p">,</span> <span class="s1">&#39;:6.2f&#39;</span><span class="p">)</span>
    <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">no_grad</span><span class="p">():</span>
        <span class="k">for</span> <span class="n">image</span><span class="p">,</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">data_loader</span><span class="p">:</span>
            <span class="n">output</span> <span class="o">=</span> <span class="n">model</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
            <span class="n">loss</span> <span class="o">=</span> <span class="n">criterion</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span>
            <span class="n">cnt</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">acc1</span><span class="p">,</span> <span class="n">acc5</span> <span class="o">=</span> <span class="n">accuracy</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">topk</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
            <span class="n">top1</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">acc1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">image</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
            <span class="n">top5</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">acc5</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">image</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">top1</span><span class="p">,</span> <span class="n">top5</span>

<span class="k">def</span> <span class="nf">load_model</span><span class="p">(</span><span class="n">model_file</span><span class="p">):</span>
    <span class="n">model</span> <span class="o">=</span> <span class="n">resnet18</span><span class="p">(</span><span class="n">pretrained</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">state_dict</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">model_file</span><span class="p">)</span>
    <span class="n">model</span><span class="o">.</span><span class="n">load_state_dict</span><span class="p">(</span><span class="n">state_dict</span><span class="p">)</span>
    <span class="n">model</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="s1">&#39;cpu&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">model</span>

<span class="k">def</span> <span class="nf">print_size_of_model</span><span class="p">(</span><span class="n">model</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">jit</span><span class="o">.</span><span class="n">RecursiveScriptModule</span><span class="p">):</span>
        <span class="n">torch</span><span class="o">.</span><span class="n">jit</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="s2">&quot;temp.p&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">torch</span><span class="o">.</span><span class="n">jit</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">jit</span><span class="o">.</span><span class="n">script</span><span class="p">(</span><span class="n">model</span><span class="p">),</span> <span class="s2">&quot;temp.p&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Size (MB):&#39;</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">getsize</span><span class="p">(</span><span class="s2">&quot;temp.p&quot;</span><span class="p">)</span><span class="o">/</span><span class="mf">1e6</span><span class="p">)</span>
    <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="s1">&#39;temp.p&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">prepare_data_loaders</span><span class="p">(</span><span class="n">data_path</span><span class="p">):</span>

    <span class="n">traindir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">data_path</span><span class="p">,</span> <span class="s1">&#39;train&#39;</span><span class="p">)</span>
    <span class="n">valdir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">data_path</span><span class="p">,</span> <span class="s1">&#39;val&#39;</span><span class="p">)</span>
    <span class="n">normalize</span> <span class="o">=</span> <span class="n">transforms</span><span class="o">.</span><span class="n">Normalize</span><span class="p">(</span><span class="n">mean</span><span class="o">=</span><span class="p">[</span><span class="mf">0.485</span><span class="p">,</span> <span class="mf">0.456</span><span class="p">,</span> <span class="mf">0.406</span><span class="p">],</span>
                                     <span class="n">std</span><span class="o">=</span><span class="p">[</span><span class="mf">0.229</span><span class="p">,</span> <span class="mf">0.224</span><span class="p">,</span> <span class="mf">0.225</span><span class="p">])</span>

    <span class="n">dataset</span> <span class="o">=</span> <span class="n">torchvision</span><span class="o">.</span><span class="n">datasets</span><span class="o">.</span><span class="n">ImageFolder</span><span class="p">(</span>
        <span class="n">traindir</span><span class="p">,</span>
        <span class="n">transforms</span><span class="o">.</span><span class="n">Compose</span><span class="p">([</span>
            <span class="n">transforms</span><span class="o">.</span><span class="n">RandomResizedCrop</span><span class="p">(</span><span class="mi">224</span><span class="p">),</span>
            <span class="n">transforms</span><span class="o">.</span><span class="n">RandomHorizontalFlip</span><span class="p">(),</span>
            <span class="n">transforms</span><span class="o">.</span><span class="n">ToTensor</span><span class="p">(),</span>
            <span class="n">normalize</span><span class="p">,</span>
        <span class="p">]))</span>

    <span class="n">dataset_test</span> <span class="o">=</span> <span class="n">torchvision</span><span class="o">.</span><span class="n">datasets</span><span class="o">.</span><span class="n">ImageFolder</span><span class="p">(</span>
        <span class="n">valdir</span><span class="p">,</span>
        <span class="n">transforms</span><span class="o">.</span><span class="n">Compose</span><span class="p">([</span>
            <span class="n">transforms</span><span class="o">.</span><span class="n">Resize</span><span class="p">(</span><span class="mi">256</span><span class="p">),</span>
            <span class="n">transforms</span><span class="o">.</span><span class="n">CenterCrop</span><span class="p">(</span><span class="mi">224</span><span class="p">),</span>
            <span class="n">transforms</span><span class="o">.</span><span class="n">ToTensor</span><span class="p">(),</span>
            <span class="n">normalize</span><span class="p">,</span>
        <span class="p">]))</span>

    <span class="n">train_sampler</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">RandomSampler</span><span class="p">(</span><span class="n">dataset</span><span class="p">)</span>
    <span class="n">test_sampler</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">SequentialSampler</span><span class="p">(</span><span class="n">dataset_test</span><span class="p">)</span>

    <span class="n">data_loader</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">DataLoader</span><span class="p">(</span>
        <span class="n">dataset</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="n">train_batch_size</span><span class="p">,</span>
        <span class="n">sampler</span><span class="o">=</span><span class="n">train_sampler</span><span class="p">)</span>

    <span class="n">data_loader_test</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">DataLoader</span><span class="p">(</span>
        <span class="n">dataset_test</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="n">eval_batch_size</span><span class="p">,</span>
        <span class="n">sampler</span><span class="o">=</span><span class="n">test_sampler</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">data_loader</span><span class="p">,</span> <span class="n">data_loader_test</span>

<span class="n">data_path</span> <span class="o">=</span> <span class="s1">&#39;data/imagenet_1k&#39;</span>
<span class="n">saved_model_dir</span> <span class="o">=</span> <span class="s1">&#39;data/&#39;</span>
<span class="n">float_model_file</span> <span class="o">=</span> <span class="s1">&#39;resnet18_pretrained_float.pth&#39;</span>

<span class="n">train_batch_size</span> <span class="o">=</span> <span class="mi">30</span>
<span class="n">eval_batch_size</span> <span class="o">=</span> <span class="mi">30</span>

<span class="n">data_loader</span><span class="p">,</span> <span class="n">data_loader_test</span> <span class="o">=</span> <span class="n">prepare_data_loaders</span><span class="p">(</span><span class="n">data_path</span><span class="p">)</span>
<span class="n">criterion</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">CrossEntropyLoss</span><span class="p">()</span>
<span class="n">float_model</span> <span class="o">=</span> <span class="n">load_model</span><span class="p">(</span><span class="n">saved_model_dir</span> <span class="o">+</span> <span class="n">float_model_file</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="s1">&#39;cpu&#39;</span><span class="p">)</span>
<span class="n">float_model</span><span class="o">.</span><span class="n">eval</span><span class="p">();</span>
</pre></div>
</div>
</div>
<div class="section" id="script-trace-the-model">
<h2>3. Script/Trace the model<a class="headerlink" href="#script-trace-the-model" title="Permalink to this headline">¶</a></h2>
<p>The input for graph mode quantization is a TorchScript model, so we’ll need to either script or trace the model first.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ts_model</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">jit</span><span class="o">.</span><span class="n">script</span><span class="p">(</span><span class="n">float_model</span><span class="p">)</span><span class="o">.</span><span class="n">eval</span><span class="p">()</span> <span class="c1"># ts_model = torch.jit.trace(float_model, input)</span>
</pre></div>
</div>
</div>
<div class="section" id="specify-how-to-quantize-the-model-with-qconfig-dict">
<h2>4. Specify how to quantize the model with <code class="docutils literal notranslate"><span class="pre">qconfig_dict</span></code><a class="headerlink" href="#specify-how-to-quantize-the-model-with-qconfig-dict" title="Permalink to this headline">¶</a></h2>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">qconfig_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;&#39;</span> <span class="p">:</span> <span class="n">default_qconfig</span><span class="p">}</span>
</pre></div>
</div>
<p>We use the same <code class="docutils literal notranslate"><span class="pre">qconfig</span></code> used in eager mode quantization, <code class="docutils literal notranslate"><span class="pre">qconfig</span></code> is just a named tuple of the observers for <code class="docutils literal notranslate"><span class="pre">activation</span></code> and <code class="docutils literal notranslate"><span class="pre">weight</span></code>. <cite>qconfig_dict</cite> is a dictionary with names of sub modules as key and qconfig for that module as value, empty key means the qconfig will be applied to whole model unless it’s overwritten by more specific configurations, the qconfig for each module is either found in the dictionary or fallback to the qconfig of parent module.</p>
<p>Right now <code class="docutils literal notranslate"><span class="pre">qconfig_dict</span></code> is the only way to configure how the model is quantized, and it is done in the granularity of module, that is, we only support one type of <code class="docutils literal notranslate"><span class="pre">qconfig</span></code> for each <code class="docutils literal notranslate"><span class="pre">torch.nn.Module</span></code>, for example, if we have:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">qconfig</span> <span class="o">=</span> <span class="p">{</span>
      <span class="s1">&#39;&#39;</span> <span class="p">:</span> <span class="n">qconfig_global</span><span class="p">,</span>
     <span class="s1">&#39;sub&#39;</span> <span class="p">:</span> <span class="n">qconfig_sub</span><span class="p">,</span>
      <span class="s1">&#39;sub.fc&#39;</span> <span class="p">:</span> <span class="n">qconfig_fc</span><span class="p">,</span>
     <span class="s1">&#39;sub.conv&#39;</span><span class="p">:</span> <span class="bp">None</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Module <code class="docutils literal notranslate"><span class="pre">sub.fc</span></code> will be configured with <code class="docutils literal notranslate"><span class="pre">qconfig_fc</span></code>, and all other child modules in <code class="docutils literal notranslate"><span class="pre">sub</span></code> will be configured with <code class="docutils literal notranslate"><span class="pre">qconfig_sub</span></code> and <code class="docutils literal notranslate"><span class="pre">sub.conv</span></code> will not be quantized. All other modules in the model will be quantized with <code class="docutils literal notranslate"><span class="pre">qconfig_global</span></code>
Utility functions related to <code class="docutils literal notranslate"><span class="pre">qconfig</span></code> can be found in <a class="reference external" href="https://github.com/pytorch/pytorch/blob/master/torch/quantization/qconfig.py">https://github.com/pytorch/pytorch/blob/master/torch/quantization/qconfig.py</a>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">qconfig</span> <span class="o">=</span> <span class="n">get_default_qconfig</span><span class="p">(</span><span class="s1">&#39;fbgemm&#39;</span><span class="p">)</span>
<span class="n">qconfig_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;&#39;</span><span class="p">:</span> <span class="n">qconfig</span><span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="define-calibration-function">
<h2>5. Define Calibration Function<a class="headerlink" href="#define-calibration-function" title="Permalink to this headline">¶</a></h2>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">calibrate</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">sample_data</span><span class="p">,</span> <span class="o">...</span><span class="p">):</span>
    <span class="n">model</span><span class="p">(</span><span class="n">sample_data</span><span class="p">,</span> <span class="o">...</span><span class="p">)</span>
</pre></div>
</div>
<p>Calibration function is run after the observers are inserted in the model.
The purpose for calibration is to run through some sample examples that is representative of the workload
(for example a sample of the training data set) so that the observers in the model are able to observe
the statistics of the Tensors and we can later use this information to calculate quantization parameters.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">calibrate</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">data_loader</span><span class="p">):</span>
    <span class="n">model</span><span class="o">.</span><span class="n">eval</span><span class="p">()</span>
    <span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">no_grad</span><span class="p">():</span>
        <span class="k">for</span> <span class="n">image</span><span class="p">,</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">data_loader</span><span class="p">:</span>
            <span class="n">model</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="quantize">
<h2>6. Quantize<a class="headerlink" href="#quantize" title="Permalink to this headline">¶</a></h2>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">quantized_model</span> <span class="o">=</span> <span class="n">quantize_jit</span><span class="p">(</span>
    <span class="n">ts_model</span><span class="p">,</span> <span class="c1"># TorchScript model</span>
    <span class="p">{</span><span class="s1">&#39;&#39;</span><span class="p">:</span> <span class="n">qconfig</span><span class="p">},</span> <span class="c1"># qconfig dict</span>
    <span class="n">calibrate</span><span class="p">,</span> <span class="c1"># calibration function</span>
    <span class="p">[</span><span class="n">data_loader_test</span><span class="p">],</span> <span class="c1"># positional arguments to calibration function, typically some sample dataset</span>
    <span class="n">inplace</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="c1"># whether to modify the model inplace or not</span>
    <span class="n">debug</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span> <span class="c1"># whether to prduce a debug friendly model or not</span>
</pre></div>
</div>
<p>There are three things we do in <code class="docutils literal notranslate"><span class="pre">quantize_jit</span></code>:</p>
<ol class="arabic simple">
<li><p><code class="docutils literal notranslate"><span class="pre">prepare_jit</span></code> folds BatchNorm modules into previous Conv2d modules, and insert observers in appropriate places in the Torchscript model.</p></li>
<li><p>Run calibrate function on the provided sample dataset.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">convert_jit</span></code> takes a calibrated model and produces a quantized model.</p></li>
</ol>
<p>If <code class="docutils literal notranslate"><span class="pre">debug</span></code> is False (default option), <code class="docutils literal notranslate"><span class="pre">convert_jit</span></code> will:</p>
<ul class="simple">
<li><p>Calculate quantization parameters using the observers in the model</p></li>
<li><p>Ifnsert quantization ops like <code class="docutils literal notranslate"><span class="pre">aten::quantize_per_tensor</span></code> and <code class="docutils literal notranslate"><span class="pre">aten::dequantize</span></code> to the model, and remove the observer modules after that.</p></li>
<li><p>Replace floating point ops with quantized ops</p></li>
<li><p>Freeze the model (remove constant attributes and make them as Constant node in the graph).</p></li>
<li><p>Fold the quantize and prepack ops like <code class="docutils literal notranslate"><span class="pre">quantized::conv2d_prepack</span></code> into an attribute, so we don’t need to quantize and prepack the weight everytime we run the model.</p></li>
</ul>
<p>If <code class="docutils literal notranslate"><span class="pre">debug</span></code> is set to <code class="docutils literal notranslate"><span class="pre">True</span></code>:</p>
<ul class="simple">
<li><p>We can still access the attributes of the quantized model the same way as the original floating point model, e.g. <code class="docutils literal notranslate"><span class="pre">model.conv1.weight</span></code> (might be harder if you use a module list or sequential)</p></li>
<li><p>The arithmetic operations all occur in floating point with the numerics being identical to the final quantized model, allowing for debugging.</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">quantized_model</span> <span class="o">=</span> <span class="n">quantize_jit</span><span class="p">(</span>
    <span class="n">ts_model</span><span class="p">,</span>
    <span class="p">{</span><span class="s1">&#39;&#39;</span><span class="p">:</span> <span class="n">qconfig</span><span class="p">},</span>
    <span class="n">calibrate</span><span class="p">,</span>
    <span class="p">[</span><span class="n">data_loader_test</span><span class="p">])</span>

<span class="nb">print</span><span class="p">(</span><span class="n">quantized_model</span><span class="o">.</span><span class="n">graph</span><span class="p">)</span>
</pre></div>
</div>
<p class="sphx-glr-script-out">Out:</p>
<div class="sphx-glr-script-out highlight-none notranslate"><div class="highlight"><pre><span></span>graph(%self : __torch__.torchvision.models.resnet.___torch_mangle_228.ResNet,
      %x.2 : Tensor):
  %639 : QInt8(1000:512, 512:1) = prim::Constant[value=&lt;Tensor&gt;]()
  %637 : QInt8(512:4608, 512:9, 3:3, 3:1) = prim::Constant[value=&lt;Tensor&gt;]()
  %635 : QInt8(512:4608, 512:9, 3:3, 3:1) = prim::Constant[value=&lt;Tensor&gt;]()
  %633 : QInt8(512:256, 256:1, 1:1, 1:1) = prim::Constant[value=&lt;Tensor&gt;]()
  %631 : QInt8(512:4608, 512:9, 3:3, 3:1) = prim::Constant[value=&lt;Tensor&gt;]()
  %629 : QInt8(512:2304, 256:9, 3:3, 3:1) = prim::Constant[value=&lt;Tensor&gt;]()
  %627 : QInt8(256:2304, 256:9, 3:3, 3:1) = prim::Constant[value=&lt;Tensor&gt;]()
  %625 : QInt8(256:2304, 256:9, 3:3, 3:1) = prim::Constant[value=&lt;Tensor&gt;]()
  %623 : QInt8(256:128, 128:1, 1:1, 1:1) = prim::Constant[value=&lt;Tensor&gt;]()
  %621 : QInt8(256:2304, 256:9, 3:3, 3:1) = prim::Constant[value=&lt;Tensor&gt;]()
  %619 : QInt8(256:1152, 128:9, 3:3, 3:1) = prim::Constant[value=&lt;Tensor&gt;]()
  %617 : QInt8(128:1152, 128:9, 3:3, 3:1) = prim::Constant[value=&lt;Tensor&gt;]()
  %615 : QInt8(128:1152, 128:9, 3:3, 3:1) = prim::Constant[value=&lt;Tensor&gt;]()
  %613 : QInt8(128:64, 64:1, 1:1, 1:1) = prim::Constant[value=&lt;Tensor&gt;]()
  %611 : QInt8(128:1152, 128:9, 3:3, 3:1) = prim::Constant[value=&lt;Tensor&gt;]()
  %609 : QInt8(128:576, 64:9, 3:3, 3:1) = prim::Constant[value=&lt;Tensor&gt;]()
  %607 : QInt8(64:576, 64:9, 3:3, 3:1) = prim::Constant[value=&lt;Tensor&gt;]()
  %605 : QInt8(64:576, 64:9, 3:3, 3:1) = prim::Constant[value=&lt;Tensor&gt;]()
  %603 : QInt8(64:576, 64:9, 3:3, 3:1) = prim::Constant[value=&lt;Tensor&gt;]()
  %601 : QInt8(64:576, 64:9, 3:3, 3:1) = prim::Constant[value=&lt;Tensor&gt;]()
  %599 : QInt8(64:147, 3:49, 7:7, 7:1) = prim::Constant[value=&lt;Tensor&gt;]()
  %14 : int = prim::Constant[value=-1]()
  %13 : int = prim::Constant[value=1]() # /home/reserve/.pyenv/versions/3.6.7/envs/pytorch/lib/python3.6/site-packages/torchvision/models/resnet.py:214:29
  %12 : int[] = prim::Constant[value=[2, 2]]()
  %11 : int[] = prim::Constant[value=[3, 3]]()
  %10 : int[] = prim::Constant[value=[1, 1]]()
  %9 : int = prim::Constant[value=2]() # /home/reserve/.pyenv/versions/3.6.7/envs/pytorch/lib/python3.6/site-packages/torch/nn/modules/pooling.py:157:53
  %8 : bool = prim::Constant[value=0]() # /home/reserve/.pyenv/versions/3.6.7/envs/pytorch/lib/python3.6/site-packages/torch/nn/modules/pooling.py:158:57
  %7 : int[] = prim::Constant[value=[0, 0]]()
  %6 : str = prim::Constant[value=&quot;Exception&quot;]() # &lt;string&gt;:5:2
  %self.4_zero_point_0 : int = prim::Constant[value=34]()
  %self.4_scale_0 : float = prim::Constant[value=0.28741154074668884]()
  %self.fc.bias : Float(1000:1) = prim::Constant[value=&lt;Tensor&gt;]()
  %self.layer4.1.out.14_scale_0 : float = prim::Constant[value=0.19620364904403687]()
  %self.layer4.1.out.8_zero_point_0 : int = prim::Constant[value=41]()
  %self.layer4.1.out.8_scale_0 : float = prim::Constant[value=0.2577512264251709]()
  %self.layer4.1.conv2.bias : Float(512:1) = prim::Constant[value=&lt;Tensor&gt;]()
  %self.layer4.1.out.6_scale_0 : float = prim::Constant[value=0.014143082313239574]()
  %self.layer4.1.conv1.bias : Float(512:1) = prim::Constant[value=&lt;Tensor&gt;]()
  %self.layer4.0.out.14_scale_0 : float = prim::Constant[value=0.03087528795003891]()
  %self.layer4.0.identity.2_zero_point_0 : int = prim::Constant[value=64]()
  %self.layer4.0.identity.2_scale_0 : float = prim::Constant[value=0.037815552204847336]()
  %self.layer4.0.downsample.0.bias : Float(512:1) = prim::Constant[value=&lt;Tensor&gt;]()
  %self.layer4.0.out.8_zero_point_0 : int = prim::Constant[value=65]()
  %self.layer4.0.out.8_scale_0 : float = prim::Constant[value=0.053702641278505325]()
  %self.layer4.0.conv2.bias : Float(512:1) = prim::Constant[value=&lt;Tensor&gt;]()
  %self.layer4.0.out.6_scale_0 : float = prim::Constant[value=0.013209396041929722]()
  %self.layer4.0.conv1.bias : Float(512:1) = prim::Constant[value=&lt;Tensor&gt;]()
  %self.layer3.1.out.14_scale_0 : float = prim::Constant[value=0.02887437492609024]()
  %self.layer3.1.out.8_zero_point_0 : int = prim::Constant[value=75]()
  %self.layer3.1.out.8_scale_0 : float = prim::Constant[value=0.051453046500682831]()
  %self.layer3.1.conv2.bias : Float(256:1) = prim::Constant[value=&lt;Tensor&gt;]()
  %self.layer3.1.out.6_scale_0 : float = prim::Constant[value=0.01376732811331749]()
  %self.layer3.1.conv1.bias : Float(256:1) = prim::Constant[value=&lt;Tensor&gt;]()
  %self.layer3.0.out.14_scale_0 : float = prim::Constant[value=0.026459669694304466]()
  %self.layer3.0.identity.2_zero_point_0 : int = prim::Constant[value=81]()
  %self.layer3.0.identity.2_scale_0 : float = prim::Constant[value=0.015993364155292511]()
  %self.layer3.0.downsample.0.bias : Float(256:1) = prim::Constant[value=&lt;Tensor&gt;]()
  %self.layer3.0.out.8_zero_point_0 : int = prim::Constant[value=45]()
  %self.layer3.0.out.8_scale_0 : float = prim::Constant[value=0.05363830178976059]()
  %self.layer3.0.conv2.bias : Float(256:1) = prim::Constant[value=&lt;Tensor&gt;]()
  %self.layer3.0.out.6_scale_0 : float = prim::Constant[value=0.018105363473296165]()
  %self.layer3.0.conv1.bias : Float(256:1) = prim::Constant[value=&lt;Tensor&gt;]()
  %self.layer2.1.out.14_scale_0 : float = prim::Constant[value=0.031941868364810944]()
  %self.layer2.1.out.8_zero_point_0 : int = prim::Constant[value=70]()
  %self.layer2.1.out.8_scale_0 : float = prim::Constant[value=0.046229708939790726]()
  %self.layer2.1.conv2.bias : Float(128:1) = prim::Constant[value=&lt;Tensor&gt;]()
  %self.layer2.1.out.6_scale_0 : float = prim::Constant[value=0.013803998939692974]()
  %self.layer2.1.conv1.bias : Float(128:1) = prim::Constant[value=&lt;Tensor&gt;]()
  %self.layer2.0.out.14_scale_0 : float = prim::Constant[value=0.026813706383109093]()
  %self.layer2.0.identity.2_zero_point_0 : int = prim::Constant[value=67]()
  %self.layer2.0.identity.2_scale_0 : float = prim::Constant[value=0.034867286682128906]()
  %self.layer2.0.downsample.0.bias : Float(128:1) = prim::Constant[value=&lt;Tensor&gt;]()
  %self.layer2.0.out.8_scale_0 : float = prim::Constant[value=0.045976739376783371]()
  %self.layer2.0.conv2.bias : Float(128:1) = prim::Constant[value=&lt;Tensor&gt;]()
  %self.layer2.0.out.6_scale_0 : float = prim::Constant[value=0.013110089115798473]()
  %self.layer2.0.conv1.bias : Float(128:1) = prim::Constant[value=&lt;Tensor&gt;]()
  %self.layer1.1.out.14_scale_0 : float = prim::Constant[value=0.036671146750450134]()
  %self.layer1.1.out.8_zero_point_0 : int = prim::Constant[value=79]()
  %self.layer1.1.out.8_scale_0 : float = prim::Constant[value=0.063445292413234711]()
  %self.layer1.1.conv2.bias : Float(64:1) = prim::Constant[value=&lt;Tensor&gt;]()
  %self.layer1.1.out.6_scale_0 : float = prim::Constant[value=0.014171220362186432]()
  %self.layer1.1.conv1.bias : Float(64:1) = prim::Constant[value=&lt;Tensor&gt;]()
  %self.layer1.0.out.14_scale_0 : float = prim::Constant[value=0.033903006464242935]()
  %self.layer1.0.out.8_zero_point_0 : int = prim::Constant[value=73]()
  %self.layer1.0.out.8_scale_0 : float = prim::Constant[value=0.05241066962480545]()
  %self.layer1.0.conv2.bias : Float(64:1) = prim::Constant[value=&lt;Tensor&gt;]()
  %self.layer1.0.out.6_scale_0 : float = prim::Constant[value=0.01314008142799139]()
  %self.layer1.0.conv1.bias : Float(64:1) = prim::Constant[value=&lt;Tensor&gt;]()
  %self.x.8_scale_0 : float = prim::Constant[value=0.026803469285368919]()
  %self.conv1.bias : Float(64:1) = prim::Constant[value=&lt;Tensor&gt;]()
  %self.conv1.2_axis_0 : int = prim::Constant[value=0]()
  %self.x.2_scalar_type_0 : int = prim::Constant[value=13]()
  %self.x.2_zero_point_0 : int = prim::Constant[value=57]()
  %self.x.2_scale_0 : float = prim::Constant[value=0.037445519119501114]()
  %x.2.quant : Tensor = aten::quantize_per_tensor(%x.2, %self.x.2_scale_0, %self.x.2_zero_point_0, %self.x.2_scalar_type_0)
  %641 : __torch__.torch.classes.quantized.Conv2dPackedParamsBase = prim::GetAttr[name=&quot;quantized._jit_pass_packed_weight_0&quot;](%self)
  %27 : Tensor = quantized::conv2d_relu(%x.2.quant, %641, %self.x.8_scale_0, %self.conv1.2_axis_0)
  %x.9 : Tensor = aten::max_pool2d(%27, %11, %12, %10, %10, %8) # /home/reserve/.pyenv/versions/3.6.7/envs/pytorch/lib/python3.6/site-packages/torch/nn/functional.py:575:11
  %642 : __torch__.torch.classes.quantized.Conv2dPackedParamsBase = prim::GetAttr[name=&quot;quantized._jit_pass_packed_weight_1&quot;](%self)
  %48 : Tensor = quantized::conv2d_relu(%x.9, %642, %self.layer1.0.out.6_scale_0, %self.conv1.2_axis_0)
  %643 : __torch__.torch.classes.quantized.Conv2dPackedParamsBase = prim::GetAttr[name=&quot;quantized._jit_pass_packed_weight_2&quot;](%self)
  %61 : Tensor = quantized::conv2d(%48, %643, %self.layer1.0.out.8_scale_0, %self.layer1.0.out.8_zero_point_0)
  %65 : Tensor = quantized::add_relu(%61, %x.9, %self.layer1.0.out.14_scale_0, %self.conv1.2_axis_0)
  %644 : __torch__.torch.classes.quantized.Conv2dPackedParamsBase = prim::GetAttr[name=&quot;quantized._jit_pass_packed_weight_3&quot;](%self)
  %78 : Tensor = quantized::conv2d_relu(%65, %644, %self.layer1.1.out.6_scale_0, %self.conv1.2_axis_0)
  %645 : __torch__.torch.classes.quantized.Conv2dPackedParamsBase = prim::GetAttr[name=&quot;quantized._jit_pass_packed_weight_4&quot;](%self)
  %91 : Tensor = quantized::conv2d(%78, %645, %self.layer1.1.out.8_scale_0, %self.layer1.1.out.8_zero_point_0)
  %95 : Tensor = quantized::add_relu(%91, %65, %self.layer1.1.out.14_scale_0, %self.conv1.2_axis_0)
  %646 : __torch__.torch.classes.quantized.Conv2dPackedParamsBase = prim::GetAttr[name=&quot;quantized._jit_pass_packed_weight_5&quot;](%self)
  %111 : Tensor = quantized::conv2d_relu(%95, %646, %self.layer2.0.out.6_scale_0, %self.conv1.2_axis_0)
  %647 : __torch__.torch.classes.quantized.Conv2dPackedParamsBase = prim::GetAttr[name=&quot;quantized._jit_pass_packed_weight_6&quot;](%self)
  %124 : Tensor = quantized::conv2d(%111, %647, %self.layer2.0.out.8_scale_0, %self.x.2_zero_point_0)
  %648 : __torch__.torch.classes.quantized.Conv2dPackedParamsBase = prim::GetAttr[name=&quot;quantized._jit_pass_packed_weight_7&quot;](%self)
  %138 : Tensor = quantized::conv2d(%95, %648, %self.layer2.0.identity.2_scale_0, %self.layer2.0.identity.2_zero_point_0)
  %142 : Tensor = quantized::add_relu(%124, %138, %self.layer2.0.out.14_scale_0, %self.conv1.2_axis_0)
  %649 : __torch__.torch.classes.quantized.Conv2dPackedParamsBase = prim::GetAttr[name=&quot;quantized._jit_pass_packed_weight_8&quot;](%self)
  %155 : Tensor = quantized::conv2d_relu(%142, %649, %self.layer2.1.out.6_scale_0, %self.conv1.2_axis_0)
  %650 : __torch__.torch.classes.quantized.Conv2dPackedParamsBase = prim::GetAttr[name=&quot;quantized._jit_pass_packed_weight_9&quot;](%self)
  %168 : Tensor = quantized::conv2d(%155, %650, %self.layer2.1.out.8_scale_0, %self.layer2.1.out.8_zero_point_0)
  %172 : Tensor = quantized::add_relu(%168, %142, %self.layer2.1.out.14_scale_0, %self.conv1.2_axis_0)
  %651 : __torch__.torch.classes.quantized.Conv2dPackedParamsBase = prim::GetAttr[name=&quot;quantized._jit_pass_packed_weight_10&quot;](%self)
  %188 : Tensor = quantized::conv2d_relu(%172, %651, %self.layer3.0.out.6_scale_0, %self.conv1.2_axis_0)
  %652 : __torch__.torch.classes.quantized.Conv2dPackedParamsBase = prim::GetAttr[name=&quot;quantized._jit_pass_packed_weight_11&quot;](%self)
  %201 : Tensor = quantized::conv2d(%188, %652, %self.layer3.0.out.8_scale_0, %self.layer3.0.out.8_zero_point_0)
  %653 : __torch__.torch.classes.quantized.Conv2dPackedParamsBase = prim::GetAttr[name=&quot;quantized._jit_pass_packed_weight_12&quot;](%self)
  %215 : Tensor = quantized::conv2d(%172, %653, %self.layer3.0.identity.2_scale_0, %self.layer3.0.identity.2_zero_point_0)
  %219 : Tensor = quantized::add_relu(%201, %215, %self.layer3.0.out.14_scale_0, %self.conv1.2_axis_0)
  %654 : __torch__.torch.classes.quantized.Conv2dPackedParamsBase = prim::GetAttr[name=&quot;quantized._jit_pass_packed_weight_13&quot;](%self)
  %232 : Tensor = quantized::conv2d_relu(%219, %654, %self.layer3.1.out.6_scale_0, %self.conv1.2_axis_0)
  %655 : __torch__.torch.classes.quantized.Conv2dPackedParamsBase = prim::GetAttr[name=&quot;quantized._jit_pass_packed_weight_14&quot;](%self)
  %245 : Tensor = quantized::conv2d(%232, %655, %self.layer3.1.out.8_scale_0, %self.layer3.1.out.8_zero_point_0)
  %249 : Tensor = quantized::add_relu(%245, %219, %self.layer3.1.out.14_scale_0, %self.conv1.2_axis_0)
  %656 : __torch__.torch.classes.quantized.Conv2dPackedParamsBase = prim::GetAttr[name=&quot;quantized._jit_pass_packed_weight_15&quot;](%self)
  %265 : Tensor = quantized::conv2d_relu(%249, %656, %self.layer4.0.out.6_scale_0, %self.conv1.2_axis_0)
  %657 : __torch__.torch.classes.quantized.Conv2dPackedParamsBase = prim::GetAttr[name=&quot;quantized._jit_pass_packed_weight_16&quot;](%self)
  %278 : Tensor = quantized::conv2d(%265, %657, %self.layer4.0.out.8_scale_0, %self.layer4.0.out.8_zero_point_0)
  %658 : __torch__.torch.classes.quantized.Conv2dPackedParamsBase = prim::GetAttr[name=&quot;quantized._jit_pass_packed_weight_17&quot;](%self)
  %292 : Tensor = quantized::conv2d(%249, %658, %self.layer4.0.identity.2_scale_0, %self.layer4.0.identity.2_zero_point_0)
  %296 : Tensor = quantized::add_relu(%278, %292, %self.layer4.0.out.14_scale_0, %self.conv1.2_axis_0)
  %659 : __torch__.torch.classes.quantized.Conv2dPackedParamsBase = prim::GetAttr[name=&quot;quantized._jit_pass_packed_weight_18&quot;](%self)
  %309 : Tensor = quantized::conv2d_relu(%296, %659, %self.layer4.1.out.6_scale_0, %self.conv1.2_axis_0)
  %660 : __torch__.torch.classes.quantized.Conv2dPackedParamsBase = prim::GetAttr[name=&quot;quantized._jit_pass_packed_weight_19&quot;](%self)
  %322 : Tensor = quantized::conv2d(%309, %660, %self.layer4.1.out.8_scale_0, %self.layer4.1.out.8_zero_point_0)
  %326 : Tensor = quantized::add_relu(%322, %296, %self.layer4.1.out.14_scale_0, %self.conv1.2_axis_0)
  %328 : int[] = aten::size(%326) # /home/reserve/.pyenv/versions/3.6.7/envs/pytorch/lib/python3.6/site-packages/torch/nn/functional.py:925:51
  %329 : int = aten::len(%328) # &lt;string&gt;:5:9
  %330 : bool = aten::gt(%329, %9) # &lt;string&gt;:5:9
   = prim::If(%330) # &lt;string&gt;:5:2
    block0():
      -&gt; ()
    block1():
       = prim::RaiseException(%6) # &lt;string&gt;:5:2
      -&gt; ()
  %331 : Tensor = aten::adaptive_avg_pool2d(%326, %10)
  %x.21 : Tensor = aten::flatten(%331, %13, %14) # /home/reserve/.pyenv/versions/3.6.7/envs/pytorch/lib/python3.6/site-packages/torchvision/models/resnet.py:214:12
  %661 : __torch__.torch.classes.quantized.LinearPackedParamsBase = prim::GetAttr[name=&quot;quantized._jit_pass_packed_weight_20&quot;](%self)
  %345 : Tensor = quantized::linear(%x.21, %661, %self.4_scale_0, %self.4_zero_point_0)
  %4.dequant.0 : Tensor = aten::dequantize(%345)
  return (%4.dequant.0)
</pre></div>
</div>
<p>As we can see <code class="docutils literal notranslate"><span class="pre">aten::conv2d</span></code> is changed to <code class="docutils literal notranslate"><span class="pre">quantized::conv2d</span></code> and the floating point weight has been quantized
and packed into an attribute (<code class="docutils literal notranslate"><span class="pre">quantized._jit_pass_packed_weight_30</span></code>), so we don’t need to quantize/pack in runtime.
Also we can’t access the weight attributes anymore after the debug option since they are frozen.</p>
</div>
<div class="section" id="evaluation">
<h2>7. Evaluation<a class="headerlink" href="#evaluation" title="Permalink to this headline">¶</a></h2>
<p>We can now print the size and accuracy of the quantized model.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Size of model before quantization&#39;</span><span class="p">)</span>
<span class="n">print_size_of_model</span><span class="p">(</span><span class="n">ts_model</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Size of model after quantization&#39;</span><span class="p">)</span>
<span class="n">print_size_of_model</span><span class="p">(</span><span class="n">quantized_model</span><span class="p">)</span>
<span class="n">top1</span><span class="p">,</span> <span class="n">top5</span> <span class="o">=</span> <span class="n">evaluate</span><span class="p">(</span><span class="n">quantized_model</span><span class="p">,</span> <span class="n">criterion</span><span class="p">,</span> <span class="n">data_loader_test</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;[before serilaization] Evaluation accuracy on test dataset: </span><span class="si">%2.2f</span><span class="s1">, </span><span class="si">%2.2f</span><span class="s1">&#39;</span><span class="o">%</span><span class="p">(</span><span class="n">top1</span><span class="o">.</span><span class="n">avg</span><span class="p">,</span> <span class="n">top5</span><span class="o">.</span><span class="n">avg</span><span class="p">))</span>

<span class="n">graph_mode_model_file</span> <span class="o">=</span> <span class="s1">&#39;resnet18_graph_mode_quantized.pth&#39;</span>
<span class="n">torch</span><span class="o">.</span><span class="n">jit</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">quantized_model</span><span class="p">,</span> <span class="n">saved_model_dir</span> <span class="o">+</span> <span class="n">graph_mode_model_file</span><span class="p">)</span>
<span class="n">quantized_model</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">jit</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">saved_model_dir</span> <span class="o">+</span> <span class="n">graph_mode_model_file</span><span class="p">)</span>
<span class="n">top1</span><span class="p">,</span> <span class="n">top5</span> <span class="o">=</span> <span class="n">evaluate</span><span class="p">(</span><span class="n">quantized_model</span><span class="p">,</span> <span class="n">criterion</span><span class="p">,</span> <span class="n">data_loader_test</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;[after serialization/deserialization] Evaluation accuracy on test dataset: </span><span class="si">%2.2f</span><span class="s1">, </span><span class="si">%2.2f</span><span class="s1">&#39;</span><span class="o">%</span><span class="p">(</span><span class="n">top1</span><span class="o">.</span><span class="n">avg</span><span class="p">,</span> <span class="n">top5</span><span class="o">.</span><span class="n">avg</span><span class="p">))</span>
</pre></div>
</div>
<p class="sphx-glr-script-out">Out:</p>
<div class="sphx-glr-script-out highlight-none notranslate"><div class="highlight"><pre><span></span>Size of model before quantization
Size (MB): 46.871565
Size of model after quantization
Size (MB): 11.849675

[before serilaization] Evaluation accuracy on test dataset: 68.60, 89.80

[after serialization/deserialization] Evaluation accuracy on test dataset: 68.60, 89.80
</pre></div>
</div>
<p>If you want to get better accuracy or performance,  try changing the <cite>qconfig_dict</cite>.
We plan to add support for graph mode in the Numerical Suite so that you can
easily determine the sensitivity towards quantization of different modules in a model: <a class="reference external" href="https://pytorch.org/tutorials/prototype/numeric_suite_tutorial.html">PyTorch Numeric Suite Tutorial</a></p>
</div>
<div class="section" id="debugging-quantized-model">
<h2>8. Debugging Quantized Model<a class="headerlink" href="#debugging-quantized-model" title="Permalink to this headline">¶</a></h2>
<p>We can also use debug option:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">quantized_debug_model</span> <span class="o">=</span> <span class="n">quantize_jit</span><span class="p">(</span>
    <span class="n">ts_model</span><span class="p">,</span>
    <span class="p">{</span><span class="s1">&#39;&#39;</span><span class="p">:</span> <span class="n">qconfig</span><span class="p">},</span>
    <span class="n">calibrate</span><span class="p">,</span>
    <span class="p">[</span><span class="n">data_loader_test</span><span class="p">],</span>
    <span class="n">debug</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="n">top1</span><span class="p">,</span> <span class="n">top5</span> <span class="o">=</span> <span class="n">evaluate</span><span class="p">(</span><span class="n">quantized_debug_model</span><span class="p">,</span> <span class="n">criterion</span><span class="p">,</span> <span class="n">data_loader_test</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;[debug=True] quantized model Evaluation accuracy on test dataset: </span><span class="si">%2.2f</span><span class="s1">, </span><span class="si">%2.2f</span><span class="s1">&#39;</span><span class="o">%</span><span class="p">(</span><span class="n">top1</span><span class="o">.</span><span class="n">avg</span><span class="p">,</span> <span class="n">top5</span><span class="o">.</span><span class="n">avg</span><span class="p">))</span>
</pre></div>
</div>
<p class="sphx-glr-script-out">Out:</p>
<div class="sphx-glr-script-out highlight-none notranslate"><div class="highlight"><pre><span></span>[debug=True] quantized model Evaluation accuracy on test dataset: 69.20, 90.40
</pre></div>
</div>
<p>Note that the accuracy of the debug version is close to, but not exactly the same as the non-debug
version as the debug version uses floating point ops to emulate quantized ops and the numerics match
is approximate. We are working on making this even more exact.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">quantized_debug_model</span><span class="o">.</span><span class="n">graph</span><span class="p">)</span>
</pre></div>
</div>
<p class="sphx-glr-script-out">Out:</p>
<div class="sphx-glr-script-out highlight-none notranslate"><div class="highlight"><pre><span></span>graph(%self : __torch__.torchvision.models.resnet.___torch_mangle_330.ResNet,
      %x.2 : Tensor):
  %7 : float = prim::GetAttr[name=&quot;x.2_scale_0&quot;](%self)
  %8 : int = prim::GetAttr[name=&quot;x.2_zero_point_0&quot;](%self)
  %9 : int = prim::GetAttr[name=&quot;x.2_scalar_type_0&quot;](%self)
  %x.2.quant : Tensor = aten::quantize_per_tensor(%x.2, %7, %8, %9)
  %x.2.dequant.0 : Tensor = aten::dequantize(%x.2.quant)
  %17 : str = prim::Constant[value=&quot;Exception&quot;]() # &lt;string&gt;:5:2
  %18 : int[] = prim::Constant[value=[0, 0]]()
  %19 : bool = prim::Constant[value=0]() # /home/reserve/.pyenv/versions/3.6.7/envs/pytorch/lib/python3.6/site-packages/torch/nn/modules/pooling.py:158:57
  %20 : int = prim::Constant[value=2]() # /home/reserve/.pyenv/versions/3.6.7/envs/pytorch/lib/python3.6/site-packages/torch/nn/modules/pooling.py:157:53
  %22 : int[] = prim::Constant[value=[1, 1]]()
  %23 : int[] = prim::Constant[value=[3, 3]]()
  %24 : int[] = prim::Constant[value=[2, 2]]()
  %25 : int = prim::Constant[value=1]() # /home/reserve/.pyenv/versions/3.6.7/envs/pytorch/lib/python3.6/site-packages/torchvision/models/resnet.py:214:29
  %26 : int = prim::Constant[value=-1]()
  %27 : __torch__.torch.nn.modules.conv.___torch_mangle_331.Conv2d = prim::GetAttr[name=&quot;conv1&quot;](%self)
  %28 : Tensor = prim::GetAttr[name=&quot;weight&quot;](%27)
  %29 : Float(64:1) = prim::GetAttr[name=&quot;2_scale_0&quot;](%27)
  %30 : Int(64:1) = prim::GetAttr[name=&quot;2_zero_point_0&quot;](%27)
  %31 : int = prim::GetAttr[name=&quot;2_axis_0&quot;](%27)
  %32 : int = prim::GetAttr[name=&quot;2_scalar_type_0&quot;](%27)
  %2.quant.7 : Tensor = aten::quantize_per_channel(%28, %29, %30, %31, %32)
  %2.dequant.7 : Tensor = aten::dequantize(%2.quant.7)
  %35 : Tensor? = prim::GetAttr[name=&quot;bias&quot;](%27)
  %x.3 : Tensor = aten::conv2d(%x.2.dequant.0, %2.dequant.7, %35, %24, %23, %22, %25) # /home/reserve/.pyenv/versions/3.6.7/envs/pytorch/lib/python3.6/site-packages/torch/nn/modules/conv.py:415:15
  %x.8 : Tensor = aten::relu_(%x.3) # /home/reserve/.pyenv/versions/3.6.7/envs/pytorch/lib/python3.6/site-packages/torch/nn/functional.py:1117:17
  %38 : float = prim::GetAttr[name=&quot;x.8_scale_0&quot;](%self)
  %39 : int = prim::GetAttr[name=&quot;x.8_zero_point_0&quot;](%self)
  %40 : int = prim::GetAttr[name=&quot;x.8_scalar_type_0&quot;](%self)
  %x.8.quant : Tensor = aten::quantize_per_tensor(%x.8, %38, %39, %40)
  %428 : int[] = prim::Constant[value=[3, 3]]()
  %429 : int[] = prim::Constant[value=[2, 2]]()
  %430 : int[] = prim::Constant[value=[1, 1]]()
  %431 : int[] = prim::Constant[value=[1, 1]]()
  %x.9 : Tensor = aten::max_pool2d(%x.8.quant, %428, %429, %430, %431, %19) # /home/reserve/.pyenv/versions/3.6.7/envs/pytorch/lib/python3.6/site-packages/torch/nn/functional.py:575:11
  %48 : __torch__.torch.nn.modules.container.___torch_mangle_336.Sequential = prim::GetAttr[name=&quot;layer1&quot;](%self)
  %49 : __torch__.torchvision.models.resnet.___torch_mangle_337.BasicBlock = prim::GetAttr[name=&quot;0&quot;](%48)
  %50 : __torch__.torchvision.models.resnet.___torch_mangle_337.BasicBlock = prim::GetAttr[name=&quot;1&quot;](%48)
  %51 : __torch__.torch.nn.modules.conv.___torch_mangle_338.Conv2d = prim::GetAttr[name=&quot;conv1&quot;](%49)
  %52 : Tensor = prim::GetAttr[name=&quot;weight&quot;](%51)
  %53 : Float(64:1) = prim::GetAttr[name=&quot;2_scale_0&quot;](%51)
  %54 : Int(64:1) = prim::GetAttr[name=&quot;2_zero_point_0&quot;](%51)
  %55 : int = prim::GetAttr[name=&quot;2_axis_0&quot;](%51)
  %56 : int = prim::GetAttr[name=&quot;2_scalar_type_0&quot;](%51)
  %2.quant.6 : Tensor = aten::quantize_per_channel(%52, %53, %54, %55, %56)
  %2.dequant.6 : Tensor = aten::dequantize(%2.quant.6)
  %59 : Tensor? = prim::GetAttr[name=&quot;bias&quot;](%51)
  %x.9.dequant.0 : Tensor = aten::dequantize(%x.9)
  %out.3 : Tensor = aten::conv2d(%x.9.dequant.0, %2.dequant.6, %59, %22, %22, %22, %25) # /home/reserve/.pyenv/versions/3.6.7/envs/pytorch/lib/python3.6/site-packages/torch/nn/modules/conv.py:415:15
  %out.10 : Tensor = aten::relu_(%out.3) # /home/reserve/.pyenv/versions/3.6.7/envs/pytorch/lib/python3.6/site-packages/torch/nn/functional.py:1117:17
  %62 : float = prim::GetAttr[name=&quot;out.6_scale_0&quot;](%49)
  %63 : int = prim::GetAttr[name=&quot;out.6_zero_point_0&quot;](%49)
  %64 : int = prim::GetAttr[name=&quot;out.6_scalar_type_0&quot;](%49)
  %out.6.quant.2 : Tensor = aten::quantize_per_tensor(%out.10, %62, %63, %64)
  %out.6.dequant.2 : Tensor = aten::dequantize(%out.6.quant.2)
  %67 : __torch__.torch.nn.modules.conv.___torch_mangle_338.Conv2d = prim::GetAttr[name=&quot;conv2&quot;](%49)
  %68 : Tensor = prim::GetAttr[name=&quot;weight&quot;](%67)
  %69 : Float(64:1) = prim::GetAttr[name=&quot;2_scale_0&quot;](%67)
  %70 : Int(64:1) = prim::GetAttr[name=&quot;2_zero_point_0&quot;](%67)
  %71 : int = prim::GetAttr[name=&quot;2_axis_0&quot;](%67)
  %72 : int = prim::GetAttr[name=&quot;2_scalar_type_0&quot;](%67)
  %2.quant.5 : Tensor = aten::quantize_per_channel(%68, %69, %70, %71, %72)
  %2.dequant.5 : Tensor = aten::dequantize(%2.quant.5)
  %75 : Tensor? = prim::GetAttr[name=&quot;bias&quot;](%67)
  %out.13 : Tensor = aten::conv2d(%out.6.dequant.2, %2.dequant.5, %75, %22, %22, %22, %25) # /home/reserve/.pyenv/versions/3.6.7/envs/pytorch/lib/python3.6/site-packages/torch/nn/modules/conv.py:415:15
  %77 : float = prim::GetAttr[name=&quot;out.8_scale_0&quot;](%49)
  %78 : int = prim::GetAttr[name=&quot;out.8_zero_point_0&quot;](%49)
  %79 : int = prim::GetAttr[name=&quot;out.8_scalar_type_0&quot;](%49)
  %out.8.quant.2 : Tensor = aten::quantize_per_tensor(%out.13, %77, %78, %79)
  %out.8.dequant.2 : Tensor = aten::dequantize(%out.8.quant.2)
  %x.9.dequant.1 : Tensor = aten::dequantize(%x.9)
  %out.16 : Tensor = aten::add_(%out.8.dequant.2, %x.9.dequant.1, %25) # /home/reserve/.pyenv/versions/3.6.7/envs/pytorch/lib/python3.6/site-packages/torchvision/models/resnet.py:69:8
  %out.17 : Tensor = aten::relu_(%out.16) # /home/reserve/.pyenv/versions/3.6.7/envs/pytorch/lib/python3.6/site-packages/torch/nn/functional.py:1117:17
  %84 : float = prim::GetAttr[name=&quot;out.14_scale_0&quot;](%49)
  %85 : int = prim::GetAttr[name=&quot;out.14_zero_point_0&quot;](%49)
  %86 : int = prim::GetAttr[name=&quot;out.14_scalar_type_0&quot;](%49)
  %out.14.quant.2 : Tensor = aten::quantize_per_tensor(%out.17, %84, %85, %86)
  %89 : __torch__.torch.nn.modules.conv.___torch_mangle_338.Conv2d = prim::GetAttr[name=&quot;conv1&quot;](%50)
  %90 : Tensor = prim::GetAttr[name=&quot;weight&quot;](%89)
  %91 : Float(64:1) = prim::GetAttr[name=&quot;2_scale_0&quot;](%89)
  %92 : Int(64:1) = prim::GetAttr[name=&quot;2_zero_point_0&quot;](%89)
  %93 : int = prim::GetAttr[name=&quot;2_axis_0&quot;](%89)
  %94 : int = prim::GetAttr[name=&quot;2_scalar_type_0&quot;](%89)
  %2.quant.8 : Tensor = aten::quantize_per_channel(%90, %91, %92, %93, %94)
  %2.dequant.8 : Tensor = aten::dequantize(%2.quant.8)
  %97 : Tensor? = prim::GetAttr[name=&quot;bias&quot;](%89)
  %input.4.dequant.0 : Tensor = aten::dequantize(%out.14.quant.2)
  %out.4 : Tensor = aten::conv2d(%input.4.dequant.0, %2.dequant.8, %97, %22, %22, %22, %25) # /home/reserve/.pyenv/versions/3.6.7/envs/pytorch/lib/python3.6/site-packages/torch/nn/modules/conv.py:415:15
  %out.18 : Tensor = aten::relu_(%out.4) # /home/reserve/.pyenv/versions/3.6.7/envs/pytorch/lib/python3.6/site-packages/torch/nn/functional.py:1117:17
  %100 : float = prim::GetAttr[name=&quot;out.6_scale_0&quot;](%50)
  %101 : int = prim::GetAttr[name=&quot;out.6_zero_point_0&quot;](%50)
  %102 : int = prim::GetAttr[name=&quot;out.6_scalar_type_0&quot;](%50)
  %out.6.quant.3 : Tensor = aten::quantize_per_tensor(%out.18, %100, %101, %102)
  %out.6.dequant.3 : Tensor = aten::dequantize(%out.6.quant.3)
  %105 : __torch__.torch.nn.modules.conv.___torch_mangle_338.Conv2d = prim::GetAttr[name=&quot;conv2&quot;](%50)
  %106 : Tensor = prim::GetAttr[name=&quot;weight&quot;](%105)
  %107 : Float(64:1) = prim::GetAttr[name=&quot;2_scale_0&quot;](%105)
  %108 : Int(64:1) = prim::GetAttr[name=&quot;2_zero_point_0&quot;](%105)
  %109 : int = prim::GetAttr[name=&quot;2_axis_0&quot;](%105)
  %110 : int = prim::GetAttr[name=&quot;2_scalar_type_0&quot;](%105)
  %2.quant.9 : Tensor = aten::quantize_per_channel(%106, %107, %108, %109, %110)
  %2.dequant.9 : Tensor = aten::dequantize(%2.quant.9)
  %113 : Tensor? = prim::GetAttr[name=&quot;bias&quot;](%105)
  %out.19 : Tensor = aten::conv2d(%out.6.dequant.3, %2.dequant.9, %113, %22, %22, %22, %25) # /home/reserve/.pyenv/versions/3.6.7/envs/pytorch/lib/python3.6/site-packages/torch/nn/modules/conv.py:415:15
  %115 : float = prim::GetAttr[name=&quot;out.8_scale_0&quot;](%50)
  %116 : int = prim::GetAttr[name=&quot;out.8_zero_point_0&quot;](%50)
  %117 : int = prim::GetAttr[name=&quot;out.8_scalar_type_0&quot;](%50)
  %out.8.quant.3 : Tensor = aten::quantize_per_tensor(%out.19, %115, %116, %117)
  %out.8.dequant.3 : Tensor = aten::dequantize(%out.8.quant.3)
  %input.4.dequant.1 : Tensor = aten::dequantize(%out.14.quant.2)
  %out.20 : Tensor = aten::add_(%out.8.dequant.3, %input.4.dequant.1, %25) # /home/reserve/.pyenv/versions/3.6.7/envs/pytorch/lib/python3.6/site-packages/torchvision/models/resnet.py:69:8
  %out.21 : Tensor = aten::relu_(%out.20) # /home/reserve/.pyenv/versions/3.6.7/envs/pytorch/lib/python3.6/site-packages/torch/nn/functional.py:1117:17
  %122 : float = prim::GetAttr[name=&quot;out.14_scale_0&quot;](%50)
  %123 : int = prim::GetAttr[name=&quot;out.14_zero_point_0&quot;](%50)
  %124 : int = prim::GetAttr[name=&quot;out.14_scalar_type_0&quot;](%50)
  %out.14.quant.3 : Tensor = aten::quantize_per_tensor(%out.21, %122, %123, %124)
  %127 : __torch__.torch.nn.modules.container.___torch_mangle_340.Sequential = prim::GetAttr[name=&quot;layer2&quot;](%self)
  %128 : __torch__.torchvision.models.resnet.___torch_mangle_341.BasicBlock = prim::GetAttr[name=&quot;0&quot;](%127)
  %129 : __torch__.torchvision.models.resnet.___torch_mangle_347.BasicBlock = prim::GetAttr[name=&quot;1&quot;](%127)
  %130 : __torch__.torch.nn.modules.conv.___torch_mangle_342.Conv2d = prim::GetAttr[name=&quot;conv1&quot;](%128)
  %131 : Tensor = prim::GetAttr[name=&quot;weight&quot;](%130)
  %132 : Float(128:1) = prim::GetAttr[name=&quot;2_scale_0&quot;](%130)
  %133 : Int(128:1) = prim::GetAttr[name=&quot;2_zero_point_0&quot;](%130)
  %134 : int = prim::GetAttr[name=&quot;2_axis_0&quot;](%130)
  %135 : int = prim::GetAttr[name=&quot;2_scalar_type_0&quot;](%130)
  %2.quant.10 : Tensor = aten::quantize_per_channel(%131, %132, %133, %134, %135)
  %2.dequant.10 : Tensor = aten::dequantize(%2.quant.10)
  %138 : Tensor? = prim::GetAttr[name=&quot;bias&quot;](%130)
  %x.11.dequant.0 : Tensor = aten::dequantize(%out.14.quant.3)
  %out.5 : Tensor = aten::conv2d(%x.11.dequant.0, %2.dequant.10, %138, %24, %22, %22, %25) # /home/reserve/.pyenv/versions/3.6.7/envs/pytorch/lib/python3.6/site-packages/torch/nn/modules/conv.py:415:15
  %out.22 : Tensor = aten::relu_(%out.5) # /home/reserve/.pyenv/versions/3.6.7/envs/pytorch/lib/python3.6/site-packages/torch/nn/functional.py:1117:17
  %141 : float = prim::GetAttr[name=&quot;out.6_scale_0&quot;](%128)
  %142 : int = prim::GetAttr[name=&quot;out.6_zero_point_0&quot;](%128)
  %143 : int = prim::GetAttr[name=&quot;out.6_scalar_type_0&quot;](%128)
  %out.6.quant.4 : Tensor = aten::quantize_per_tensor(%out.22, %141, %142, %143)
  %out.6.dequant.4 : Tensor = aten::dequantize(%out.6.quant.4)
  %146 : __torch__.torch.nn.modules.conv.___torch_mangle_344.Conv2d = prim::GetAttr[name=&quot;conv2&quot;](%128)
  %147 : Tensor = prim::GetAttr[name=&quot;weight&quot;](%146)
  %148 : Float(128:1) = prim::GetAttr[name=&quot;2_scale_0&quot;](%146)
  %149 : Int(128:1) = prim::GetAttr[name=&quot;2_zero_point_0&quot;](%146)
  %150 : int = prim::GetAttr[name=&quot;2_axis_0&quot;](%146)
  %151 : int = prim::GetAttr[name=&quot;2_scalar_type_0&quot;](%146)
  %2.quant.11 : Tensor = aten::quantize_per_channel(%147, %148, %149, %150, %151)
  %2.dequant.11 : Tensor = aten::dequantize(%2.quant.11)
  %154 : Tensor? = prim::GetAttr[name=&quot;bias&quot;](%146)
  %out.23 : Tensor = aten::conv2d(%out.6.dequant.4, %2.dequant.11, %154, %22, %22, %22, %25) # /home/reserve/.pyenv/versions/3.6.7/envs/pytorch/lib/python3.6/site-packages/torch/nn/modules/conv.py:415:15
  %156 : float = prim::GetAttr[name=&quot;out.8_scale_0&quot;](%128)
  %157 : int = prim::GetAttr[name=&quot;out.8_zero_point_0&quot;](%128)
  %158 : int = prim::GetAttr[name=&quot;out.8_scalar_type_0&quot;](%128)
  %out.8.quant.4 : Tensor = aten::quantize_per_tensor(%out.23, %156, %157, %158)
  %out.8.dequant.4 : Tensor = aten::dequantize(%out.8.quant.4)
  %161 : __torch__.torch.nn.modules.container.___torch_mangle_345.Sequential = prim::GetAttr[name=&quot;downsample&quot;](%128)
  %162 : __torch__.torch.nn.modules.conv.___torch_mangle_346.Conv2d = prim::GetAttr[name=&quot;0&quot;](%161)
  %163 : Tensor = prim::GetAttr[name=&quot;weight&quot;](%162)
  %164 : Float(128:1) = prim::GetAttr[name=&quot;2_scale_0&quot;](%162)
  %165 : Int(128:1) = prim::GetAttr[name=&quot;2_zero_point_0&quot;](%162)
  %166 : int = prim::GetAttr[name=&quot;2_axis_0&quot;](%162)
  %167 : int = prim::GetAttr[name=&quot;2_scalar_type_0&quot;](%162)
  %2.quant.12 : Tensor = aten::quantize_per_channel(%163, %164, %165, %166, %167)
  %2.dequant.12 : Tensor = aten::dequantize(%2.quant.12)
  %170 : Tensor? = prim::GetAttr[name=&quot;bias&quot;](%162)
  %x.11.dequant.1 : Tensor = aten::dequantize(%out.14.quant.3)
  %identity.3 : Tensor = aten::conv2d(%x.11.dequant.1, %2.dequant.12, %170, %24, %18, %22, %25) # /home/reserve/.pyenv/versions/3.6.7/envs/pytorch/lib/python3.6/site-packages/torch/nn/modules/conv.py:415:15
  %172 : float = prim::GetAttr[name=&quot;identity.2_scale_0&quot;](%128)
  %173 : int = prim::GetAttr[name=&quot;identity.2_zero_point_0&quot;](%128)
  %174 : int = prim::GetAttr[name=&quot;identity.2_scalar_type_0&quot;](%128)
  %identity.2.quant.1 : Tensor = aten::quantize_per_tensor(%identity.3, %172, %173, %174)
  %identity.2.dequant.1 : Tensor = aten::dequantize(%identity.2.quant.1)
  %out.24 : Tensor = aten::add_(%out.8.dequant.4, %identity.2.dequant.1, %25) # /home/reserve/.pyenv/versions/3.6.7/envs/pytorch/lib/python3.6/site-packages/torchvision/models/resnet.py:69:8
  %out.25 : Tensor = aten::relu_(%out.24) # /home/reserve/.pyenv/versions/3.6.7/envs/pytorch/lib/python3.6/site-packages/torch/nn/functional.py:1117:17
  %179 : float = prim::GetAttr[name=&quot;out.14_scale_0&quot;](%128)
  %180 : int = prim::GetAttr[name=&quot;out.14_zero_point_0&quot;](%128)
  %181 : int = prim::GetAttr[name=&quot;out.14_scalar_type_0&quot;](%128)
  %out.14.quant.4 : Tensor = aten::quantize_per_tensor(%out.25, %179, %180, %181)
  %184 : __torch__.torch.nn.modules.conv.___torch_mangle_344.Conv2d = prim::GetAttr[name=&quot;conv1&quot;](%129)
  %185 : Tensor = prim::GetAttr[name=&quot;weight&quot;](%184)
  %186 : Float(128:1) = prim::GetAttr[name=&quot;2_scale_0&quot;](%184)
  %187 : Int(128:1) = prim::GetAttr[name=&quot;2_zero_point_0&quot;](%184)
  %188 : int = prim::GetAttr[name=&quot;2_axis_0&quot;](%184)
  %189 : int = prim::GetAttr[name=&quot;2_scalar_type_0&quot;](%184)
  %2.quant.13 : Tensor = aten::quantize_per_channel(%185, %186, %187, %188, %189)
  %2.dequant.13 : Tensor = aten::dequantize(%2.quant.13)
  %192 : Tensor? = prim::GetAttr[name=&quot;bias&quot;](%184)
  %input.6.dequant.0 : Tensor = aten::dequantize(%out.14.quant.4)
  %out.26 : Tensor = aten::conv2d(%input.6.dequant.0, %2.dequant.13, %192, %22, %22, %22, %25) # /home/reserve/.pyenv/versions/3.6.7/envs/pytorch/lib/python3.6/site-packages/torch/nn/modules/conv.py:415:15
  %out.27 : Tensor = aten::relu_(%out.26) # /home/reserve/.pyenv/versions/3.6.7/envs/pytorch/lib/python3.6/site-packages/torch/nn/functional.py:1117:17
  %195 : float = prim::GetAttr[name=&quot;out.6_scale_0&quot;](%129)
  %196 : int = prim::GetAttr[name=&quot;out.6_zero_point_0&quot;](%129)
  %197 : int = prim::GetAttr[name=&quot;out.6_scalar_type_0&quot;](%129)
  %out.6.quant.5 : Tensor = aten::quantize_per_tensor(%out.27, %195, %196, %197)
  %out.6.dequant.5 : Tensor = aten::dequantize(%out.6.quant.5)
  %200 : __torch__.torch.nn.modules.conv.___torch_mangle_344.Conv2d = prim::GetAttr[name=&quot;conv2&quot;](%129)
  %201 : Tensor = prim::GetAttr[name=&quot;weight&quot;](%200)
  %202 : Float(128:1) = prim::GetAttr[name=&quot;2_scale_0&quot;](%200)
  %203 : Int(128:1) = prim::GetAttr[name=&quot;2_zero_point_0&quot;](%200)
  %204 : int = prim::GetAttr[name=&quot;2_axis_0&quot;](%200)
  %205 : int = prim::GetAttr[name=&quot;2_scalar_type_0&quot;](%200)
  %2.quant.14 : Tensor = aten::quantize_per_channel(%201, %202, %203, %204, %205)
  %2.dequant.14 : Tensor = aten::dequantize(%2.quant.14)
  %208 : Tensor? = prim::GetAttr[name=&quot;bias&quot;](%200)
  %out.28 : Tensor = aten::conv2d(%out.6.dequant.5, %2.dequant.14, %208, %22, %22, %22, %25) # /home/reserve/.pyenv/versions/3.6.7/envs/pytorch/lib/python3.6/site-packages/torch/nn/modules/conv.py:415:15
  %210 : float = prim::GetAttr[name=&quot;out.8_scale_0&quot;](%129)
  %211 : int = prim::GetAttr[name=&quot;out.8_zero_point_0&quot;](%129)
  %212 : int = prim::GetAttr[name=&quot;out.8_scalar_type_0&quot;](%129)
  %out.8.quant.5 : Tensor = aten::quantize_per_tensor(%out.28, %210, %211, %212)
  %out.8.dequant.5 : Tensor = aten::dequantize(%out.8.quant.5)
  %input.6.dequant.1 : Tensor = aten::dequantize(%out.14.quant.4)
  %out.29 : Tensor = aten::add_(%out.8.dequant.5, %input.6.dequant.1, %25) # /home/reserve/.pyenv/versions/3.6.7/envs/pytorch/lib/python3.6/site-packages/torchvision/models/resnet.py:69:8
  %out.30 : Tensor = aten::relu_(%out.29) # /home/reserve/.pyenv/versions/3.6.7/envs/pytorch/lib/python3.6/site-packages/torch/nn/functional.py:1117:17
  %217 : float = prim::GetAttr[name=&quot;out.14_scale_0&quot;](%129)
  %218 : int = prim::GetAttr[name=&quot;out.14_zero_point_0&quot;](%129)
  %219 : int = prim::GetAttr[name=&quot;out.14_scalar_type_0&quot;](%129)
  %out.14.quant.5 : Tensor = aten::quantize_per_tensor(%out.30, %217, %218, %219)
  %222 : __torch__.torch.nn.modules.container.___torch_mangle_348.Sequential = prim::GetAttr[name=&quot;layer3&quot;](%self)
  %223 : __torch__.torchvision.models.resnet.___torch_mangle_349.BasicBlock = prim::GetAttr[name=&quot;0&quot;](%222)
  %224 : __torch__.torchvision.models.resnet.___torch_mangle_355.BasicBlock = prim::GetAttr[name=&quot;1&quot;](%222)
  %225 : __torch__.torch.nn.modules.conv.___torch_mangle_350.Conv2d = prim::GetAttr[name=&quot;conv1&quot;](%223)
  %226 : Tensor = prim::GetAttr[name=&quot;weight&quot;](%225)
  %227 : Float(256:1) = prim::GetAttr[name=&quot;2_scale_0&quot;](%225)
  %228 : Int(256:1) = prim::GetAttr[name=&quot;2_zero_point_0&quot;](%225)
  %229 : int = prim::GetAttr[name=&quot;2_axis_0&quot;](%225)
  %230 : int = prim::GetAttr[name=&quot;2_scalar_type_0&quot;](%225)
  %2.quant.15 : Tensor = aten::quantize_per_channel(%226, %227, %228, %229, %230)
  %2.dequant.15 : Tensor = aten::dequantize(%2.quant.15)
  %233 : Tensor? = prim::GetAttr[name=&quot;bias&quot;](%225)
  %x.13.dequant.0 : Tensor = aten::dequantize(%out.14.quant.5)
  %out.31 : Tensor = aten::conv2d(%x.13.dequant.0, %2.dequant.15, %233, %24, %22, %22, %25) # /home/reserve/.pyenv/versions/3.6.7/envs/pytorch/lib/python3.6/site-packages/torch/nn/modules/conv.py:415:15
  %out.32 : Tensor = aten::relu_(%out.31) # /home/reserve/.pyenv/versions/3.6.7/envs/pytorch/lib/python3.6/site-packages/torch/nn/functional.py:1117:17
  %236 : float = prim::GetAttr[name=&quot;out.6_scale_0&quot;](%223)
  %237 : int = prim::GetAttr[name=&quot;out.6_zero_point_0&quot;](%223)
  %238 : int = prim::GetAttr[name=&quot;out.6_scalar_type_0&quot;](%223)
  %out.6.quant.6 : Tensor = aten::quantize_per_tensor(%out.32, %236, %237, %238)
  %out.6.dequant.6 : Tensor = aten::dequantize(%out.6.quant.6)
  %241 : __torch__.torch.nn.modules.conv.___torch_mangle_352.Conv2d = prim::GetAttr[name=&quot;conv2&quot;](%223)
  %242 : Tensor = prim::GetAttr[name=&quot;weight&quot;](%241)
  %243 : Float(256:1) = prim::GetAttr[name=&quot;2_scale_0&quot;](%241)
  %244 : Int(256:1) = prim::GetAttr[name=&quot;2_zero_point_0&quot;](%241)
  %245 : int = prim::GetAttr[name=&quot;2_axis_0&quot;](%241)
  %246 : int = prim::GetAttr[name=&quot;2_scalar_type_0&quot;](%241)
  %2.quant.16 : Tensor = aten::quantize_per_channel(%242, %243, %244, %245, %246)
  %2.dequant.16 : Tensor = aten::dequantize(%2.quant.16)
  %249 : Tensor? = prim::GetAttr[name=&quot;bias&quot;](%241)
  %out.33 : Tensor = aten::conv2d(%out.6.dequant.6, %2.dequant.16, %249, %22, %22, %22, %25) # /home/reserve/.pyenv/versions/3.6.7/envs/pytorch/lib/python3.6/site-packages/torch/nn/modules/conv.py:415:15
  %251 : float = prim::GetAttr[name=&quot;out.8_scale_0&quot;](%223)
  %252 : int = prim::GetAttr[name=&quot;out.8_zero_point_0&quot;](%223)
  %253 : int = prim::GetAttr[name=&quot;out.8_scalar_type_0&quot;](%223)
  %out.8.quant.6 : Tensor = aten::quantize_per_tensor(%out.33, %251, %252, %253)
  %out.8.dequant.6 : Tensor = aten::dequantize(%out.8.quant.6)
  %256 : __torch__.torch.nn.modules.container.___torch_mangle_353.Sequential = prim::GetAttr[name=&quot;downsample&quot;](%223)
  %257 : __torch__.torch.nn.modules.conv.___torch_mangle_354.Conv2d = prim::GetAttr[name=&quot;0&quot;](%256)
  %258 : Tensor = prim::GetAttr[name=&quot;weight&quot;](%257)
  %259 : Float(256:1) = prim::GetAttr[name=&quot;2_scale_0&quot;](%257)
  %260 : Int(256:1) = prim::GetAttr[name=&quot;2_zero_point_0&quot;](%257)
  %261 : int = prim::GetAttr[name=&quot;2_axis_0&quot;](%257)
  %262 : int = prim::GetAttr[name=&quot;2_scalar_type_0&quot;](%257)
  %2.quant.17 : Tensor = aten::quantize_per_channel(%258, %259, %260, %261, %262)
  %2.dequant.17 : Tensor = aten::dequantize(%2.quant.17)
  %265 : Tensor? = prim::GetAttr[name=&quot;bias&quot;](%257)
  %x.13.dequant.1 : Tensor = aten::dequantize(%out.14.quant.5)
  %identity.4 : Tensor = aten::conv2d(%x.13.dequant.1, %2.dequant.17, %265, %24, %18, %22, %25) # /home/reserve/.pyenv/versions/3.6.7/envs/pytorch/lib/python3.6/site-packages/torch/nn/modules/conv.py:415:15
  %267 : float = prim::GetAttr[name=&quot;identity.2_scale_0&quot;](%223)
  %268 : int = prim::GetAttr[name=&quot;identity.2_zero_point_0&quot;](%223)
  %269 : int = prim::GetAttr[name=&quot;identity.2_scalar_type_0&quot;](%223)
  %identity.2.quant.2 : Tensor = aten::quantize_per_tensor(%identity.4, %267, %268, %269)
  %identity.2.dequant.2 : Tensor = aten::dequantize(%identity.2.quant.2)
  %out.34 : Tensor = aten::add_(%out.8.dequant.6, %identity.2.dequant.2, %25) # /home/reserve/.pyenv/versions/3.6.7/envs/pytorch/lib/python3.6/site-packages/torchvision/models/resnet.py:69:8
  %out.35 : Tensor = aten::relu_(%out.34) # /home/reserve/.pyenv/versions/3.6.7/envs/pytorch/lib/python3.6/site-packages/torch/nn/functional.py:1117:17
  %274 : float = prim::GetAttr[name=&quot;out.14_scale_0&quot;](%223)
  %275 : int = prim::GetAttr[name=&quot;out.14_zero_point_0&quot;](%223)
  %276 : int = prim::GetAttr[name=&quot;out.14_scalar_type_0&quot;](%223)
  %out.14.quant.6 : Tensor = aten::quantize_per_tensor(%out.35, %274, %275, %276)
  %279 : __torch__.torch.nn.modules.conv.___torch_mangle_352.Conv2d = prim::GetAttr[name=&quot;conv1&quot;](%224)
  %280 : Tensor = prim::GetAttr[name=&quot;weight&quot;](%279)
  %281 : Float(256:1) = prim::GetAttr[name=&quot;2_scale_0&quot;](%279)
  %282 : Int(256:1) = prim::GetAttr[name=&quot;2_zero_point_0&quot;](%279)
  %283 : int = prim::GetAttr[name=&quot;2_axis_0&quot;](%279)
  %284 : int = prim::GetAttr[name=&quot;2_scalar_type_0&quot;](%279)
  %2.quant.18 : Tensor = aten::quantize_per_channel(%280, %281, %282, %283, %284)
  %2.dequant.18 : Tensor = aten::dequantize(%2.quant.18)
  %287 : Tensor? = prim::GetAttr[name=&quot;bias&quot;](%279)
  %input.7.dequant.0 : Tensor = aten::dequantize(%out.14.quant.6)
  %out.36 : Tensor = aten::conv2d(%input.7.dequant.0, %2.dequant.18, %287, %22, %22, %22, %25) # /home/reserve/.pyenv/versions/3.6.7/envs/pytorch/lib/python3.6/site-packages/torch/nn/modules/conv.py:415:15
  %out.37 : Tensor = aten::relu_(%out.36) # /home/reserve/.pyenv/versions/3.6.7/envs/pytorch/lib/python3.6/site-packages/torch/nn/functional.py:1117:17
  %290 : float = prim::GetAttr[name=&quot;out.6_scale_0&quot;](%224)
  %291 : int = prim::GetAttr[name=&quot;out.6_zero_point_0&quot;](%224)
  %292 : int = prim::GetAttr[name=&quot;out.6_scalar_type_0&quot;](%224)
  %out.6.quant.7 : Tensor = aten::quantize_per_tensor(%out.37, %290, %291, %292)
  %out.6.dequant.7 : Tensor = aten::dequantize(%out.6.quant.7)
  %295 : __torch__.torch.nn.modules.conv.___torch_mangle_352.Conv2d = prim::GetAttr[name=&quot;conv2&quot;](%224)
  %296 : Tensor = prim::GetAttr[name=&quot;weight&quot;](%295)
  %297 : Float(256:1) = prim::GetAttr[name=&quot;2_scale_0&quot;](%295)
  %298 : Int(256:1) = prim::GetAttr[name=&quot;2_zero_point_0&quot;](%295)
  %299 : int = prim::GetAttr[name=&quot;2_axis_0&quot;](%295)
  %300 : int = prim::GetAttr[name=&quot;2_scalar_type_0&quot;](%295)
  %2.quant.19 : Tensor = aten::quantize_per_channel(%296, %297, %298, %299, %300)
  %2.dequant.19 : Tensor = aten::dequantize(%2.quant.19)
  %303 : Tensor? = prim::GetAttr[name=&quot;bias&quot;](%295)
  %out.38 : Tensor = aten::conv2d(%out.6.dequant.7, %2.dequant.19, %303, %22, %22, %22, %25) # /home/reserve/.pyenv/versions/3.6.7/envs/pytorch/lib/python3.6/site-packages/torch/nn/modules/conv.py:415:15
  %305 : float = prim::GetAttr[name=&quot;out.8_scale_0&quot;](%224)
  %306 : int = prim::GetAttr[name=&quot;out.8_zero_point_0&quot;](%224)
  %307 : int = prim::GetAttr[name=&quot;out.8_scalar_type_0&quot;](%224)
  %out.8.quant.7 : Tensor = aten::quantize_per_tensor(%out.38, %305, %306, %307)
  %out.8.dequant.7 : Tensor = aten::dequantize(%out.8.quant.7)
  %input.7.dequant.1 : Tensor = aten::dequantize(%out.14.quant.6)
  %out.39 : Tensor = aten::add_(%out.8.dequant.7, %input.7.dequant.1, %25) # /home/reserve/.pyenv/versions/3.6.7/envs/pytorch/lib/python3.6/site-packages/torchvision/models/resnet.py:69:8
  %out.40 : Tensor = aten::relu_(%out.39) # /home/reserve/.pyenv/versions/3.6.7/envs/pytorch/lib/python3.6/site-packages/torch/nn/functional.py:1117:17
  %312 : float = prim::GetAttr[name=&quot;out.14_scale_0&quot;](%224)
  %313 : int = prim::GetAttr[name=&quot;out.14_zero_point_0&quot;](%224)
  %314 : int = prim::GetAttr[name=&quot;out.14_scalar_type_0&quot;](%224)
  %out.14.quant.7 : Tensor = aten::quantize_per_tensor(%out.40, %312, %313, %314)
  %317 : __torch__.torch.nn.modules.container.___torch_mangle_356.Sequential = prim::GetAttr[name=&quot;layer4&quot;](%self)
  %318 : __torch__.torchvision.models.resnet.___torch_mangle_357.BasicBlock = prim::GetAttr[name=&quot;0&quot;](%317)
  %319 : __torch__.torchvision.models.resnet.___torch_mangle_363.BasicBlock = prim::GetAttr[name=&quot;1&quot;](%317)
  %320 : __torch__.torch.nn.modules.conv.___torch_mangle_358.Conv2d = prim::GetAttr[name=&quot;conv1&quot;](%318)
  %321 : Tensor = prim::GetAttr[name=&quot;weight&quot;](%320)
  %322 : Float(512:1) = prim::GetAttr[name=&quot;2_scale_0&quot;](%320)
  %323 : Int(512:1) = prim::GetAttr[name=&quot;2_zero_point_0&quot;](%320)
  %324 : int = prim::GetAttr[name=&quot;2_axis_0&quot;](%320)
  %325 : int = prim::GetAttr[name=&quot;2_scalar_type_0&quot;](%320)
  %2.quant.3 : Tensor = aten::quantize_per_channel(%321, %322, %323, %324, %325)
  %2.dequant.3 : Tensor = aten::dequantize(%2.quant.3)
  %328 : Tensor? = prim::GetAttr[name=&quot;bias&quot;](%320)
  %x.15.dequant.0 : Tensor = aten::dequantize(%out.14.quant.7)
  %out.2 : Tensor = aten::conv2d(%x.15.dequant.0, %2.dequant.3, %328, %24, %22, %22, %25) # /home/reserve/.pyenv/versions/3.6.7/envs/pytorch/lib/python3.6/site-packages/torch/nn/modules/conv.py:415:15
  %out.7 : Tensor = aten::relu_(%out.2) # /home/reserve/.pyenv/versions/3.6.7/envs/pytorch/lib/python3.6/site-packages/torch/nn/functional.py:1117:17
  %331 : float = prim::GetAttr[name=&quot;out.6_scale_0&quot;](%318)
  %332 : int = prim::GetAttr[name=&quot;out.6_zero_point_0&quot;](%318)
  %333 : int = prim::GetAttr[name=&quot;out.6_scalar_type_0&quot;](%318)
  %out.6.quant.1 : Tensor = aten::quantize_per_tensor(%out.7, %331, %332, %333)
  %out.6.dequant.1 : Tensor = aten::dequantize(%out.6.quant.1)
  %336 : __torch__.torch.nn.modules.conv.___torch_mangle_360.Conv2d = prim::GetAttr[name=&quot;conv2&quot;](%318)
  %337 : Tensor = prim::GetAttr[name=&quot;weight&quot;](%336)
  %338 : Float(512:1) = prim::GetAttr[name=&quot;2_scale_0&quot;](%336)
  %339 : Int(512:1) = prim::GetAttr[name=&quot;2_zero_point_0&quot;](%336)
  %340 : int = prim::GetAttr[name=&quot;2_axis_0&quot;](%336)
  %341 : int = prim::GetAttr[name=&quot;2_scalar_type_0&quot;](%336)
  %2.quant.2 : Tensor = aten::quantize_per_channel(%337, %338, %339, %340, %341)
  %2.dequant.2 : Tensor = aten::dequantize(%2.quant.2)
  %344 : Tensor? = prim::GetAttr[name=&quot;bias&quot;](%336)
  %out.9 : Tensor = aten::conv2d(%out.6.dequant.1, %2.dequant.2, %344, %22, %22, %22, %25) # /home/reserve/.pyenv/versions/3.6.7/envs/pytorch/lib/python3.6/site-packages/torch/nn/modules/conv.py:415:15
  %346 : float = prim::GetAttr[name=&quot;out.8_scale_0&quot;](%318)
  %347 : int = prim::GetAttr[name=&quot;out.8_zero_point_0&quot;](%318)
  %348 : int = prim::GetAttr[name=&quot;out.8_scalar_type_0&quot;](%318)
  %out.8.quant.1 : Tensor = aten::quantize_per_tensor(%out.9, %346, %347, %348)
  %out.8.dequant.1 : Tensor = aten::dequantize(%out.8.quant.1)
  %351 : __torch__.torch.nn.modules.container.___torch_mangle_361.Sequential = prim::GetAttr[name=&quot;downsample&quot;](%318)
  %352 : __torch__.torch.nn.modules.conv.___torch_mangle_362.Conv2d = prim::GetAttr[name=&quot;0&quot;](%351)
  %353 : Tensor = prim::GetAttr[name=&quot;weight&quot;](%352)
  %354 : Float(512:1) = prim::GetAttr[name=&quot;2_scale_0&quot;](%352)
  %355 : Int(512:1) = prim::GetAttr[name=&quot;2_zero_point_0&quot;](%352)
  %356 : int = prim::GetAttr[name=&quot;2_axis_0&quot;](%352)
  %357 : int = prim::GetAttr[name=&quot;2_scalar_type_0&quot;](%352)
  %2.quant.4 : Tensor = aten::quantize_per_channel(%353, %354, %355, %356, %357)
  %2.dequant.4 : Tensor = aten::dequantize(%2.quant.4)
  %360 : Tensor? = prim::GetAttr[name=&quot;bias&quot;](%352)
  %x.15.dequant.1 : Tensor = aten::dequantize(%out.14.quant.7)
  %identity.2 : Tensor = aten::conv2d(%x.15.dequant.1, %2.dequant.4, %360, %24, %18, %22, %25) # /home/reserve/.pyenv/versions/3.6.7/envs/pytorch/lib/python3.6/site-packages/torch/nn/modules/conv.py:415:15
  %362 : float = prim::GetAttr[name=&quot;identity.2_scale_0&quot;](%318)
  %363 : int = prim::GetAttr[name=&quot;identity.2_zero_point_0&quot;](%318)
  %364 : int = prim::GetAttr[name=&quot;identity.2_scalar_type_0&quot;](%318)
  %identity.2.quant : Tensor = aten::quantize_per_tensor(%identity.2, %362, %363, %364)
  %identity.2.dequant.0 : Tensor = aten::dequantize(%identity.2.quant)
  %out.12 : Tensor = aten::add_(%out.8.dequant.1, %identity.2.dequant.0, %25) # /home/reserve/.pyenv/versions/3.6.7/envs/pytorch/lib/python3.6/site-packages/torchvision/models/resnet.py:69:8
  %out.15 : Tensor = aten::relu_(%out.12) # /home/reserve/.pyenv/versions/3.6.7/envs/pytorch/lib/python3.6/site-packages/torch/nn/functional.py:1117:17
  %369 : float = prim::GetAttr[name=&quot;out.14_scale_0&quot;](%318)
  %370 : int = prim::GetAttr[name=&quot;out.14_zero_point_0&quot;](%318)
  %371 : int = prim::GetAttr[name=&quot;out.14_scalar_type_0&quot;](%318)
  %out.14.quant.1 : Tensor = aten::quantize_per_tensor(%out.15, %369, %370, %371)
  %374 : __torch__.torch.nn.modules.conv.___torch_mangle_360.Conv2d = prim::GetAttr[name=&quot;conv1&quot;](%319)
  %375 : Tensor = prim::GetAttr[name=&quot;weight&quot;](%374)
  %376 : Float(512:1) = prim::GetAttr[name=&quot;2_scale_0&quot;](%374)
  %377 : Int(512:1) = prim::GetAttr[name=&quot;2_zero_point_0&quot;](%374)
  %378 : int = prim::GetAttr[name=&quot;2_axis_0&quot;](%374)
  %379 : int = prim::GetAttr[name=&quot;2_scalar_type_0&quot;](%374)
  %2.quant.1 : Tensor = aten::quantize_per_channel(%375, %376, %377, %378, %379)
  %2.dequant.1 : Tensor = aten::dequantize(%2.quant.1)
  %382 : Tensor? = prim::GetAttr[name=&quot;bias&quot;](%374)
  %input.3.dequant.0 : Tensor = aten::dequantize(%out.14.quant.1)
  %out.1 : Tensor = aten::conv2d(%input.3.dequant.0, %2.dequant.1, %382, %22, %22, %22, %25) # /home/reserve/.pyenv/versions/3.6.7/envs/pytorch/lib/python3.6/site-packages/torch/nn/modules/conv.py:415:15
  %out.6 : Tensor = aten::relu_(%out.1) # /home/reserve/.pyenv/versions/3.6.7/envs/pytorch/lib/python3.6/site-packages/torch/nn/functional.py:1117:17
  %385 : float = prim::GetAttr[name=&quot;out.6_scale_0&quot;](%319)
  %386 : int = prim::GetAttr[name=&quot;out.6_zero_point_0&quot;](%319)
  %387 : int = prim::GetAttr[name=&quot;out.6_scalar_type_0&quot;](%319)
  %out.6.quant : Tensor = aten::quantize_per_tensor(%out.6, %385, %386, %387)
  %out.6.dequant.0 : Tensor = aten::dequantize(%out.6.quant)
  %390 : __torch__.torch.nn.modules.conv.___torch_mangle_360.Conv2d = prim::GetAttr[name=&quot;conv2&quot;](%319)
  %391 : Tensor = prim::GetAttr[name=&quot;weight&quot;](%390)
  %392 : Float(512:1) = prim::GetAttr[name=&quot;2_scale_0&quot;](%390)
  %393 : Int(512:1) = prim::GetAttr[name=&quot;2_zero_point_0&quot;](%390)
  %394 : int = prim::GetAttr[name=&quot;2_axis_0&quot;](%390)
  %395 : int = prim::GetAttr[name=&quot;2_scalar_type_0&quot;](%390)
  %2.quant : Tensor = aten::quantize_per_channel(%391, %392, %393, %394, %395)
  %2.dequant.0 : Tensor = aten::dequantize(%2.quant)
  %398 : Tensor? = prim::GetAttr[name=&quot;bias&quot;](%390)
  %out.8 : Tensor = aten::conv2d(%out.6.dequant.0, %2.dequant.0, %398, %22, %22, %22, %25) # /home/reserve/.pyenv/versions/3.6.7/envs/pytorch/lib/python3.6/site-packages/torch/nn/modules/conv.py:415:15
  %400 : float = prim::GetAttr[name=&quot;out.8_scale_0&quot;](%319)
  %401 : int = prim::GetAttr[name=&quot;out.8_zero_point_0&quot;](%319)
  %402 : int = prim::GetAttr[name=&quot;out.8_scalar_type_0&quot;](%319)
  %out.8.quant : Tensor = aten::quantize_per_tensor(%out.8, %400, %401, %402)
  %out.8.dequant.0 : Tensor = aten::dequantize(%out.8.quant)
  %input.3.dequant.1 : Tensor = aten::dequantize(%out.14.quant.1)
  %out.11 : Tensor = aten::add_(%out.8.dequant.0, %input.3.dequant.1, %25) # /home/reserve/.pyenv/versions/3.6.7/envs/pytorch/lib/python3.6/site-packages/torchvision/models/resnet.py:69:8
  %out.14 : Tensor = aten::relu_(%out.11) # /home/reserve/.pyenv/versions/3.6.7/envs/pytorch/lib/python3.6/site-packages/torch/nn/functional.py:1117:17
  %407 : float = prim::GetAttr[name=&quot;out.14_scale_0&quot;](%319)
  %408 : int = prim::GetAttr[name=&quot;out.14_zero_point_0&quot;](%319)
  %409 : int = prim::GetAttr[name=&quot;out.14_scalar_type_0&quot;](%319)
  %out.14.quant : Tensor = aten::quantize_per_tensor(%out.14, %407, %408, %409)
  %432 : int[] = prim::Constant[value=[1, 1]]()
  %413 : int[] = aten::size(%out.14.quant) # /home/reserve/.pyenv/versions/3.6.7/envs/pytorch/lib/python3.6/site-packages/torch/nn/functional.py:925:51
  %414 : int = aten::len(%413) # &lt;string&gt;:5:9
  %415 : bool = aten::gt(%414, %20) # &lt;string&gt;:5:9
   = prim::If(%415) # &lt;string&gt;:5:2
    block0():
      -&gt; ()
    block1():
       = prim::RaiseException(%17) # &lt;string&gt;:5:2
      -&gt; ()
  %x.17.dequant.1 : Tensor = aten::dequantize(%out.14.quant)
  %x.19 : Tensor = aten::adaptive_avg_pool2d(%x.17.dequant.1, %432) # /home/reserve/.pyenv/versions/3.6.7/envs/pytorch/lib/python3.6/site-packages/torch/nn/functional.py:926:11
  %out.14.quant.q_scale : float = aten::q_scale(%out.14.quant)
  %out.14.quant.q_zero_point : int = aten::q_zero_point(%out.14.quant)
  %out.14.quant.dtype : int = prim::dtype(%out.14.quant)
  %x.19.quant : Tensor = aten::quantize_per_tensor(%x.19, %out.14.quant.q_scale, %out.14.quant.q_zero_point, %out.14.quant.dtype)
  %x.21 : Tensor = aten::flatten(%x.19.quant, %25, %26) # /home/reserve/.pyenv/versions/3.6.7/envs/pytorch/lib/python3.6/site-packages/torchvision/models/resnet.py:214:12
  %418 : __torch__.torch.nn.modules.linear.___torch_mangle_365.Linear = prim::GetAttr[name=&quot;fc&quot;](%self)
  %419 : Tensor = prim::GetAttr[name=&quot;weight&quot;](%418)
  %420 : Float(1000:1) = prim::GetAttr[name=&quot;3_scale_0&quot;](%418)
  %421 : Int(1000:1) = prim::GetAttr[name=&quot;3_zero_point_0&quot;](%418)
  %422 : int = prim::GetAttr[name=&quot;3_axis_0&quot;](%418)
  %423 : int = prim::GetAttr[name=&quot;3_scalar_type_0&quot;](%418)
  %3.quant : Tensor = aten::quantize_per_channel(%419, %420, %421, %422, %423)
  %3.dequant.0 : Tensor = aten::dequantize(%3.quant)
  %426 : Tensor = prim::GetAttr[name=&quot;bias&quot;](%418)
  %x.21.dequant.0 : Tensor = aten::dequantize(%x.21)
  %x.23 : Tensor = aten::linear(%x.21.dequant.0, %3.dequant.0, %426)
  %12 : float = prim::GetAttr[name=&quot;4_scale_0&quot;](%self)
  %13 : int = prim::GetAttr[name=&quot;4_zero_point_0&quot;](%self)
  %14 : int = prim::GetAttr[name=&quot;4_scalar_type_0&quot;](%self)
  %4.quant : Tensor = aten::quantize_per_tensor(%x.23, %12, %13, %14)
  %4.dequant.0 : Tensor = aten::dequantize(%4.quant)
  return (%4.dequant.0)
</pre></div>
</div>
<p>We can see that there is no <code class="docutils literal notranslate"><span class="pre">quantized::conv2d</span></code> in the model, but the numerically equivalent pattern
of <code class="docutils literal notranslate"><span class="pre">aten::dequnatize</span> <span class="pre">-</span> <span class="pre">aten::conv2d</span> <span class="pre">-</span> <span class="pre">aten::quantize_per_tensor</span></code>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">print_size_of_model</span><span class="p">(</span><span class="n">quantized_debug_model</span><span class="p">)</span>
</pre></div>
</div>
<p class="sphx-glr-script-out">Out:</p>
<div class="sphx-glr-script-out highlight-none notranslate"><div class="highlight"><pre><span></span>Size (MB): 46.956979
</pre></div>
</div>
<p>Size of the debug model is the close to the floating point model because all the weights are
in float and not yet quantized and frozen, this allows people to inspect the weight.
You may access the weight attributes directly in the torchscript model, except for batch norm as
it is fused into the preceding convolutions. We will also develop graph mode <code class="docutils literal notranslate"><span class="pre">Numeric</span> <span class="pre">Suite</span></code>
to allow easier inspection of weights in the future. Accessing the weight in the debug model is
the same as accessing the weight in a TorchScript model:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">get_first_conv_weight</span><span class="p">(</span><span class="n">model</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">model</span><span class="o">.</span><span class="n">conv1</span><span class="o">.</span><span class="n">weight</span>
<span class="n">w1</span> <span class="o">=</span> <span class="n">get_first_conv_weight</span><span class="p">(</span><span class="n">ts_model</span><span class="p">)</span>
<span class="n">w2</span> <span class="o">=</span> <span class="n">get_first_conv_weight</span><span class="p">(</span><span class="n">quantized_debug_model</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;first conv weight for input model:&#39;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">w1</span><span class="p">)[:</span><span class="mi">200</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;first conv weight for quantized model:&#39;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">w2</span><span class="p">)[:</span><span class="mi">200</span><span class="p">])</span>
</pre></div>
</div>
<p class="sphx-glr-script-out">Out:</p>
<div class="sphx-glr-script-out highlight-none notranslate"><div class="highlight"><pre><span></span>first conv weight for input model: Parameter containing:
tensor([[[[-1.0419e-02, -6.1356e-03, -1.8098e-03,  ...,  5.6615e-02,
            1.7083e-02, -1.2694e-02],
          [ 1.1083e-02,  9.5276e-03, -1.0993e-01,  ..., -2.7124e-01,

first conv weight for quantized model: tensor([[[[-2.4267e-03, -1.4290e-03, -4.2151e-04,  ...,  1.3186e-02,
            3.9788e-03, -2.9565e-03],
          [ 2.5812e-03,  2.2190e-03, -2.5603e-02,  ..., -6.3173e-02,
           -3.0062e-02,
</pre></div>
</div>
<p>The weights are different because we fold the weights of BatchNorm to the previous conv before we quantize the model.
More instructions on how to debug TorchScript model can be found <a class="reference external" href="https://pytorch.org/docs/stable/jit.html#debugging">here</a>.</p>
<p>As we can see, this is not as straightforward as eager mode, that’s why we also plan to support graph mode <code class="docutils literal notranslate"><span class="pre">Numeric</span> <span class="pre">Suite</span></code>,
and it will probably be the primary tool people use to debug numerical issues.</p>
</div>
<div class="section" id="comparison-with-baseline-float-model-and-eager-mode-quantization">
<h2>9. Comparison with Baseline Float Model and Eager Mode Quantization<a class="headerlink" href="#comparison-with-baseline-float-model-and-eager-mode-quantization" title="Permalink to this headline">¶</a></h2>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">scripted_float_model_file</span> <span class="o">=</span> <span class="s1">&#39;resnet18_scripted.pth&#39;</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Size of baseline model&#39;</span><span class="p">)</span>
<span class="n">print_size_of_model</span><span class="p">(</span><span class="n">float_model</span><span class="p">)</span>

<span class="n">top1</span><span class="p">,</span> <span class="n">top5</span> <span class="o">=</span> <span class="n">evaluate</span><span class="p">(</span><span class="n">float_model</span><span class="p">,</span> <span class="n">criterion</span><span class="p">,</span> <span class="n">data_loader_test</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Baseline Float Model Evaluation accuracy: </span><span class="si">%2.2f</span><span class="s1">, </span><span class="si">%2.2f</span><span class="s1">&#39;</span><span class="o">%</span><span class="p">(</span><span class="n">top1</span><span class="o">.</span><span class="n">avg</span><span class="p">,</span> <span class="n">top5</span><span class="o">.</span><span class="n">avg</span><span class="p">))</span>
<span class="n">torch</span><span class="o">.</span><span class="n">jit</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">jit</span><span class="o">.</span><span class="n">script</span><span class="p">(</span><span class="n">float_model</span><span class="p">),</span> <span class="n">saved_model_dir</span> <span class="o">+</span> <span class="n">scripted_float_model_file</span><span class="p">)</span>
</pre></div>
</div>
<p class="sphx-glr-script-out">Out:</p>
<div class="sphx-glr-script-out highlight-none notranslate"><div class="highlight"><pre><span></span>Size of baseline model
Size (MB): 46.871565

Baseline Float Model Evaluation accuracy: 69.30, 89.60
</pre></div>
</div>
<p>In this section we compare the model quantized with graph mode quantization with the model
quantized in eager mode. Graph mode and eager mode produce very similar quantized models,
so the expectation is that the accuracy and speedup are similar as well.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Size of graph mode quantized model&#39;</span><span class="p">)</span>
<span class="n">print_size_of_model</span><span class="p">(</span><span class="n">quantized_model</span><span class="p">)</span>
<span class="n">top1</span><span class="p">,</span> <span class="n">top5</span> <span class="o">=</span> <span class="n">evaluate</span><span class="p">(</span><span class="n">quantized_model</span><span class="p">,</span> <span class="n">criterion</span><span class="p">,</span> <span class="n">data_loader_test</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;graph mode quantized model Evaluation accuracy on test dataset: </span><span class="si">%2.2f</span><span class="s1">, </span><span class="si">%2.2f</span><span class="s1">&#39;</span><span class="o">%</span><span class="p">(</span><span class="n">top1</span><span class="o">.</span><span class="n">avg</span><span class="p">,</span> <span class="n">top5</span><span class="o">.</span><span class="n">avg</span><span class="p">))</span>

<span class="kn">from</span> <span class="nn">torchvision.models.quantization.resnet</span> <span class="k">import</span> <span class="n">resnet18</span>
<span class="n">eager_quantized_model</span> <span class="o">=</span> <span class="n">resnet18</span><span class="p">(</span><span class="n">pretrained</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">quantize</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">eval</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Size of eager mode quantized model&#39;</span><span class="p">)</span>
<span class="n">eager_quantized_model</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">jit</span><span class="o">.</span><span class="n">script</span><span class="p">(</span><span class="n">eager_quantized_model</span><span class="p">)</span>
<span class="n">print_size_of_model</span><span class="p">(</span><span class="n">eager_quantized_model</span><span class="p">)</span>
<span class="n">top1</span><span class="p">,</span> <span class="n">top5</span> <span class="o">=</span> <span class="n">evaluate</span><span class="p">(</span><span class="n">eager_quantized_model</span><span class="p">,</span> <span class="n">criterion</span><span class="p">,</span> <span class="n">data_loader_test</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;eager mode quantized model Evaluation accuracy on test dataset: </span><span class="si">%2.2f</span><span class="s1">, </span><span class="si">%2.2f</span><span class="s1">&#39;</span><span class="o">%</span><span class="p">(</span><span class="n">top1</span><span class="o">.</span><span class="n">avg</span><span class="p">,</span> <span class="n">top5</span><span class="o">.</span><span class="n">avg</span><span class="p">))</span>
<span class="n">eager_mode_model_file</span> <span class="o">=</span> <span class="s1">&#39;resnet18_eager_mode_quantized.pth&#39;</span>
<span class="n">torch</span><span class="o">.</span><span class="n">jit</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">eager_quantized_model</span><span class="p">,</span> <span class="n">saved_model_dir</span> <span class="o">+</span> <span class="n">eager_mode_model_file</span><span class="p">)</span>
</pre></div>
</div>
<p class="sphx-glr-script-out">Out:</p>
<div class="sphx-glr-script-out highlight-none notranslate"><div class="highlight"><pre><span></span>Size of graph mode quantized model
Size (MB): 11.849803

graph mode quantized model Evaluation accuracy on test dataset: 68.60, 89.80
Size of eager mode quantized model
Size (MB): 11.835043

eager mode quantized model Evaluation accuracy on test dataset: 68.70, 89.70
</pre></div>
</div>
<p>We can see that the model size and accuracy of graph mode and eager mode quantized model are pretty similar.</p>
<p>Running the model in AIBench (with single threading) gives the following result:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Scripted</span> <span class="n">Float</span> <span class="n">Model</span><span class="p">:</span>
<span class="n">Self</span> <span class="n">CPU</span> <span class="n">time</span> <span class="n">total</span><span class="p">:</span> <span class="mf">418.472</span><span class="n">ms</span>

<span class="n">Scripted</span> <span class="n">Eager</span> <span class="n">Mode</span> <span class="n">Quantized</span> <span class="n">Model</span><span class="p">:</span>
<span class="n">Self</span> <span class="n">CPU</span> <span class="n">time</span> <span class="n">total</span><span class="p">:</span> <span class="mf">177.768</span><span class="n">ms</span>

<span class="n">Graph</span> <span class="n">Mode</span> <span class="n">Quantized</span> <span class="n">Model</span><span class="p">:</span>
<span class="n">Self</span> <span class="n">CPU</span> <span class="n">time</span> <span class="n">total</span><span class="p">:</span> <span class="mf">157.256</span><span class="n">ms</span>
</pre></div>
</div>
<p>As we can see for resnet18 both graph mode and eager mode quantized model get similar speed up over the floating point model,
which is around 2-3x faster than the floating point model. But the actual speedup over floating point model may vary
depending on model, device, build, input batch sizes, threading etc.</p>
<p class="sphx-glr-timing"><strong>Total running time of the script:</strong> ( 3 minutes  47.121 seconds)</p>
<div class="sphx-glr-footer class sphx-glr-footer-example docutils container" id="sphx-glr-download-prototype-graph-mode-static-quantization-tutorial-py">
<div class="sphx-glr-download docutils container">
<p><a class="reference download internal" download="" href="../_downloads/22c959e82dde8cfb5f1b0cf5cb84f293/graph_mode_static_quantization_tutorial.py"><code class="xref download docutils literal notranslate"><span class="pre">Download</span> <span class="pre">Python</span> <span class="pre">source</span> <span class="pre">code:</span> <span class="pre">graph_mode_static_quantization_tutorial.py</span></code></a></p>
</div>
<div class="sphx-glr-download docutils container">
<p><a class="reference download internal" download="" href="../_downloads/ce0d3d42f46408ae910553ca370054c0/graph_mode_static_quantization_tutorial.ipynb"><code class="xref download docutils literal notranslate"><span class="pre">Download</span> <span class="pre">Jupyter</span> <span class="pre">notebook:</span> <span class="pre">graph_mode_static_quantization_tutorial.ipynb</span></code></a></p>
</div>
</div>
<p class="sphx-glr-signature"><a class="reference external" href="https://sphinx-gallery.readthedocs.io">Gallery generated by Sphinx-Gallery</a></p>
</div>
</div>


             </article>
             
            </div>
            <footer>
  

  

    <hr class="helpful-hr hr-top">
      <div class="helpful-container">
        <div class="helpful-question">이 문서가 도움이 되었나요?</div>
        <div class="helpful-question yes-link" data-behavior="was-this-helpful-event" data-response="yes">네</div>
        <div class="helpful-question no-link" data-behavior="was-this-helpful-event" data-response="no">아니오</div>
        <div class="was-helpful-thank-you">피드백을 주셔서 감사합니다.</div>
      </div>
    <hr class="helpful-hr hr-bottom"/>

  

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, PyTorch.

    </p>
  </div>
    
      <div>
        Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
      </div>
     

</footer>

          </div>
        </div>

        <div class="pytorch-content-right" id="pytorch-content-right">
          <div class="pytorch-right-menu" id="pytorch-right-menu">
            <div class="pytorch-side-scroll" id="pytorch-side-scroll-right">
              <ul>
<li><a class="reference internal" href="#">(prototype) Graph Mode Post Training Static Quantization in PyTorch</a><ul>
<li><a class="reference internal" href="#motivation-of-graph-mode-quantization">1. Motivation of Graph Mode Quantization</a></li>
<li><a class="reference internal" href="#define-helper-functions-and-prepare-dataset">2. Define Helper Functions and Prepare Dataset</a></li>
<li><a class="reference internal" href="#script-trace-the-model">3. Script/Trace the model</a></li>
<li><a class="reference internal" href="#specify-how-to-quantize-the-model-with-qconfig-dict">4. Specify how to quantize the model with <code class="docutils literal notranslate"><span class="pre">qconfig_dict</span></code></a></li>
<li><a class="reference internal" href="#define-calibration-function">5. Define Calibration Function</a></li>
<li><a class="reference internal" href="#quantize">6. Quantize</a></li>
<li><a class="reference internal" href="#evaluation">7. Evaluation</a></li>
<li><a class="reference internal" href="#debugging-quantized-model">8. Debugging Quantized Model</a></li>
<li><a class="reference internal" href="#comparison-with-baseline-float-model-and-eager-mode-quantization">9. Comparison with Baseline Float Model and Eager Mode Quantization</a></li>
</ul>
</li>
</ul>

            </div>
          </div>
        </div>
      </section>
    </div>

  


  

     
       <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
         <script type="text/javascript" src="../_static/jquery.js"></script>
         <script type="text/javascript" src="../_static/underscore.js"></script>
         <script type="text/javascript" src="../_static/doctools.js"></script>
         <script type="text/javascript" src="../_static/language_data.js"></script>
         <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
     

  

  <script type="text/javascript" src="../_static/js/vendor/popper.min.js"></script>
  <script type="text/javascript" src="../_static/js/vendor/bootstrap.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/list.js/1.5.0/list.min.js"></script>
  <script type="text/javascript" src="../_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
 
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-71919972-3', 'auto');
  ga('send', 'pageview');

  $("[data-behavior='call-to-action-event']").on('click', function(){
    ga('send', {
      hitType: 'event',
      eventCategory: 'Download',
      eventAction: 'click',
      eventLabel: $(this).attr("data-response")
    });
   });

   $("[data-behavior='was-this-helpful-event']").on('click', function(){
    $(".helpful-question").hide();
    $(".was-helpful-thank-you").show();
    ga('send', {
      hitType: 'event',
      eventCategory: 'Was this Helpful?',
      eventAction: 'click',
      eventLabel: $(this).attr("data-response")
    });
   });

   if (location.pathname == "/") {
     $(".helpful-container").hide();
     $(".hr-bottom").hide();
   }
</script>


  <!-- Begin Footer -->

  <div class="container-fluid docs-tutorials-resources" id="docs-tutorials-resources">
    <div class="container">
      <div class="row">
        <div class="col-md-4 text-center">
          <h2>Docs</h2>
          <p>Access comprehensive developer documentation for PyTorch</p>
          <a class="with-right-arrow" href="https://pytorch.org/docs/stable/index.html">View Docs</a>
        </div>

        <div class="col-md-4 text-center">
          <h2>Tutorials</h2>
          <p>Get in-depth tutorials for beginners and advanced developers</p>
          <a class="with-right-arrow" href="https://pytorch.org/tutorials">View Tutorials</a>
        </div>

        <div class="col-md-4 text-center">
          <h2>Resources</h2>
          <p>Find development resources and get your questions answered</p>
          <a class="with-right-arrow" href="https://pytorch.org/resources">View Resources</a>
        </div>
      </div>
    </div>
  </div>

  <footer class="site-footer">
    <div class="footer-container container">
      <div class="footer-logo-wrapper"><a href="https://pytorch.kr" class="footer-logo"></a></div>
      <div class="footer-links-wrapper pb-2">
        <div class="footer-links-col">
          <ul>
            <li class="list-title"><a href="https://pytorch.org">PyTorch 홈페이지 (공식)</a></li>
            <li><a href="https://pytorch.org">공식 홈페이지</a></li>
            <li><a href="https://pytorch.org/tutorials">공식 튜토리얼</a></li>
            <li><a href="https://pytorch.org/docs">공식 문서</a></li>
          </ul>
        </div>
        <div class="footer-links-col">
          <ul>
            <li class="list-title"><a href="https://pytorch.kr">한국어 홈페이지 (비공식)</a></li>
            <li><a href="https://pytorch.kr/about" class="">사이트 소개</a></li>
            <li><a href="https://tutorials.pytorch.kr/">한국어 튜토리얼</a></li>
            <li><a href="https://github.com/9bow/PyTorch-tutorials-kr" target="_blank">한국어 튜토리얼 저장소</a></li>
          </ul>
        </div>
      </div>
    </div>
  </footer>

  <div class="cookie-banner-wrapper">
  <div class="container">
    <p class="gdpr-notice">To analyze traffic and optimize your experience, we serve cookies on this site. By clicking or navigating, you agree to allow our usage of cookies. As the current maintainers of this site, Facebook’s Cookies Policy applies. Learn more, including about available controls: <a href="https://www.facebook.com/policies/cookies/">Cookies Policy</a>.</p>
    <img class="close-button" src="../_static/images/pytorch-x.svg">
  </div>
</div>

  <!-- End Footer -->

  <!-- Begin Mobile Menu -->

  <div class="mobile-main-menu">
    <div class="container-fluid">
      <div class="container">
        <div class="mobile-main-menu-header-container">
          <a class="header-logo" href="https://pytorch.kr/" aria-label="PyTorch"></a>
          <a class="main-menu-close-button" href="#" data-behavior="close-mobile-menu"></a>
        </div>
      </div>
    </div>

    <div class="mobile-main-menu-links-container">
      <div class="main-menu">
        <ul>
          <li>
            <a href="https://pytorch.org/get-started">Get Started</a>
          </li>

          <li>
            <a href="https://pytorch.org/features">Features</a>
          </li>

          <li>
            <a href="https://pytorch.org/ecosystem">Ecosystem</a>
          </li>

          <li>
            <a href="https://pytorch.org/mobile">Mobile</a>
          </li>

          <li>
            <a href="https://pytorch.org/hub">PyTorch Hub</a>
          </li>

          <li>
            <a href="https://pytorch.org/blog/">Blog</a>
          </li>

          <li class="active">
            <a href="https://pytorch.org/tutorials">Tutorials</a>
          </li>

          <li>
            <a href="https://pytorch.org/docs/stable/index.html">Docs</a>
          </li>

          <li>
            <a href="https://pytorch.org/resources">Resources</a>
          </li>

          <li>
            <a href="https://github.com/pytorch/pytorch">Github</a>
          </li>
        </ul>
      </div>
    </div>
  </div>

  <!-- End Mobile Menu -->

  <script type="text/javascript" src="../_static/js/vendor/anchor.min.js"></script>

  <script type="text/javascript">
    $(document).ready(function() {
      mobileMenu.bind();
      mobileTOC.bind();
      pytorchAnchors.bind();
      sideMenus.bind();
      scrollToAnchor.bind();
      highlightNavigation.bind();
      mainMenuDropdown.bind();
      filterTags.bind();

      // Add class to links that have code blocks, since we cannot create links in code blocks
      $("article.pytorch-article a span.pre").each(function(e) {
        $(this).closest("a").addClass("has-code");
      });
    })
  </script>
</body>
</html>